<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>git 中的各种撤销操作</title>
      <link href="//git-revoke-all-in-one/"/>
      <url>//git-revoke-all-in-one/</url>
      
        <content type="html"><![CDATA[<h2 id="工作区回滚：文件修改错误"><a href="#工作区回滚：文件修改错误" class="headerlink" title="工作区回滚：文件修改错误"></a>工作区回滚：文件修改错误</h2><p>使用 <code>git checkout</code> 命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看指定文件的历史版本</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> &lt;filename&gt;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">回滚到指定commitID</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout &lt;commitID&gt; &lt;filename&gt;</span></span><br></pre></td></tr></table></figure><h2 id="暂存区回滚：git-add-添加了多余文件"><a href="#暂存区回滚：git-add-添加了多余文件" class="headerlink" title="暂存区回滚：git add 添加了多余文件"></a>暂存区回滚：git add 添加了多余文件</h2><p>这样的错误是由于直接 <code>go add .</code> 一把梭，把当前目录所有文件都暂存了，不小心就会提交其他文件</p><p>撤销操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">先看一下add 中的文件</span></span><br><span class="line">git status     </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果后面什么都不跟的话 就是上一次add 里面的全部撤销了 ,HEAD 可以不写，直接git reset</span></span><br><span class="line">git reset HEAD</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">就是对某个文件进行撤销了,HEAD 可以不写，直接git reset XX文件</span></span><br><span class="line">git reset HEAD XXX/XXX/XXX.java    </span><br></pre></td></tr></table></figure><h2 id="本地仓库回滚：git-commit-了错误文件"><a href="#本地仓库回滚：git-commit-了错误文件" class="headerlink" title="本地仓库回滚：git commit 了错误文件"></a>本地仓库回滚：git commit 了错误文件</h2><p>如果不小心 弄错了 git add后 ， 又 git commit 了，但还没push到远程。</p><p>先使用 git log 查看 commit 节点的信息，关键是获取到 commit id</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">commit xxxxxxxxxxxxxxxxxxxxxxxxxx</span><br><span class="line">Merge:</span><br><span class="line">Author:</span><br><span class="line">Date:</span><br></pre></td></tr></table></figure><h3 id="方法一：git-reset"><a href="#方法一：git-reset" class="headerlink" title="方法一：git reset"></a>方法一：git reset</h3><p>使用 <code>git reset commit_id</code> 命令进行本地回滚</p><ul><li><code>git reset commit_id</code> ：mixed 模式，回退到上一个 提交的节点（即目标版本号） 代码还是原来你修改的</li><li><code>git reset –hard commit_id</code> ：回退到上一个 commit 节点， 代码也发生了改变，变成上一次的</li><li><code>git reset –soft commit_id</code>：回退到上一个 commit 节点， 工作区和暂存区还是原来你修改的</li></ul><p>使用 git reset 会将错误的 commit 节点删除</p><h3 id="方法二：git-revert"><a href="#方法二：git-revert" class="headerlink" title="方法二：git revert"></a>方法二：git revert</h3><p>使用 <code>git revert -n commit_id</code> 命令进行本地回滚</p><p>-n 参数表示不自动提交 commit，即在撤销了所有指定的 commit 后，不会立即创建新的 commit 记录撤销操作。这样可以让用户手动检查撤销的结果是否正确，并根据需要进行修改、补充等操作，最终再手动提交撤销 commit。</p><p>通过 git revert 还原已经提交的修改，此次操作之前和之后的 commit 和 history 都会保留，并且把这次撤销作为一次最新的提交。</p><p>git revert是提交一个新的版本，将需要revert的版本的内容再反向修改回去，版本会递增，不影响之前提交的内容。实际上这是<strong>用修改代替删除的一种撤销方式</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">撤销前一次 commit</span></span><br><span class="line">git revert HEAD </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">撤销前前一次 commit</span></span><br><span class="line">git revert HEAD^ </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">撤销指定的版本，撤销也会作为一次提交进行保存</span></span><br><span class="line">git revert commit-id </span><br></pre></td></tr></table></figure><h2 id="远程仓库回滚：错误的-commit-已经同步到了远程仓库"><a href="#远程仓库回滚：错误的-commit-已经同步到了远程仓库" class="headerlink" title="远程仓库回滚：错误的 commit 已经同步到了远程仓库"></a>远程仓库回滚：错误的 commit 已经同步到了远程仓库</h2><h3 id="针对-git-reset"><a href="#针对-git-reset" class="headerlink" title="针对 git reset"></a>针对 git reset</h3><p>如果使用 git reset 方法回滚的本地仓库，那么远程仓库回滚需要在本地仓库回滚的基础上，进行强制推送即可</p><p>-f 即强制推送，因为本地仓库在reset之后，版本比远程仓库低，普通推送无法推送，会报错，需要进行强制提交</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard 目标版本号</span><br><span class="line">git push -f</span><br></pre></td></tr></table></figure><h3 id="针对-git-revert"><a href="#针对-git-revert" class="headerlink" title="针对 git revert"></a>针对 git revert</h3><p>因为使用 git reset 方法并不会将历史的 commit 节点删除，所以能够正常推送</p><p>一般而言，这是首选，因为可以规避使用 <code>git push -f</code> ，防止操作失误导致数据丢失</p>]]></content>
      
      
      <categories>
          
          <category> 通用知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git Basic CheatSheet</title>
      <link href="//git-basic-cheatsheet/"/>
      <url>//git-basic-cheatsheet/</url>
      
        <content type="html"><![CDATA[<h2 id="01-Git-configuration"><a href="#01-Git-configuration" class="headerlink" title="01  Git configuration"></a>01  Git configuration</h2><p>Set the name that will be attached to your commits and tags.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;Your Name&quot;</span><br></pre></td></tr></table></figure><p>Set the e-mail address that will be attached to your commits and tags.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.email &quot;you@example.com&quot;</span><br></pre></td></tr></table></figure><p> Enable some colorization of Git output.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global color.ui auto</span><br></pre></td></tr></table></figure><h2 id="02-Starting-a-project"><a href="#02-Starting-a-project" class="headerlink" title="02  Starting a project"></a>02  Starting a project</h2><p>Create a new local repository in the current directory. If <strong>[project name]</strong> is provided, Git will create a new directory named <strong>[project name]</strong> and will initialize a repository inside it.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init [project name]</span><br></pre></td></tr></table></figure><p>Downloads a project with the entire history from the remote repository.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone &lt;project url&gt;</span><br></pre></td></tr></table></figure><h2 id="03-Day-to-day-work"><a href="#03-Day-to-day-work" class="headerlink" title="03  Day-to-day work"></a>03  Day-to-day work</h2><p>Displays the status of your working directory. Options include new, staged, and modified files. It will retrieve branch name, current commit identifier, and changes pending commit.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><p>Add a file to the <strong>staging area</strong>. Use. in place of the full file path to add all changed files from the <strong>current directory</strong> down into the <strong>directory tree</strong>.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add [file]</span><br></pre></td></tr></table></figure><p>Show changes between <strong>working directory</strong> and <strong>staging area</strong>.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff [file]</span><br></pre></td></tr></table></figure><p>Shows any changes between the <strong>staging area</strong> and the <strong>repository</strong>.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff --staged [file]</span><br></pre></td></tr></table></figure><p>Discard changes in <strong>working directory</strong>. This operation is <strong>unrecoverable</strong>.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- [file]</span><br></pre></td></tr></table></figure><p>Revert some paths in the index (or the whole index) to their state in <strong>HEAD</strong>.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset [path...]</span><br></pre></td></tr></table></figure><p>Create a new commit from changes added to the <strong>staging area</strong>. The commit must have a message!</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit</span><br></pre></td></tr></table></figure><p>Remove file from <strong>working directory</strong> and <strong>staging area</strong>.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm [file]</span><br></pre></td></tr></table></figure><h2 id="04-Storing-your-work"><a href="#04-Storing-your-work" class="headerlink" title="04  Storing your work"></a>04  Storing your work</h2><p>Put current changes in your <strong>working directory</strong> into <strong>stash</strong> for later use.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure><p>Apply stored <strong>stash</strong> content into <strong>working directory</strong>, and clear <strong>stash</strong>.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash pop</span><br></pre></td></tr></table></figure><p> Delete a specific <strong>stash</strong> from all your previous <strong>stashes</strong>.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash drop</span><br></pre></td></tr></table></figure><h2 id="05-Git-branching-model"><a href="#05-Git-branching-model" class="headerlink" title="05  Git branching model"></a>05  Git branching model</h2><ul><li>Commit a state of the code base</li><li>Branch a reference to a commit; can have a tracked upstream</li><li>Tag a reference (standard) or an object (annotated)<ul><li>HEAD a place where your working directory is now</li></ul></li></ul><p>List all local branches in repository. With <strong>-a</strong>: show all branches (with remote).</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch [-a]</span><br></pre></td></tr></table></figure><p>Create new branch, referencing the current <strong>HEAD</strong>.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch [branch_name]</span><br></pre></td></tr></table></figure><p>Apply commits of the current working branch and apply them to the HEAD of <strong>[branch]</strong> to make the history of your branch more linear.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase [branch_name]</span><br></pre></td></tr></table></figure><p>Switch working directory to the specified branch. With <strong>-b</strong>: Git will create the specified branch if it does not exist.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout [-b] [branch_name]</span><br></pre></td></tr></table></figure><p>Join specified <strong>[branch_name]</strong> branch into your current branch (the one you are on currently)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge [branch_name]</span><br></pre></td></tr></table></figure><p> Remove selected branch, if it is already merged into any other. <strong>-D</strong> instead of <strong>-d</strong> forces deletion.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d [branch_name]</span><br></pre></td></tr></table></figure><h2 id="06-Inspect-history"><a href="#06-Inspect-history" class="headerlink" title="06  Inspect history"></a>06  Inspect history</h2><p>List commit history of current branch. -n count limits list to last n commits.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log [-n count]</span><br></pre></td></tr></table></figure><p>An overview with reference labels and history graph. One commit per line.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --oneline --graph --decora</span><br></pre></td></tr></table></figure><p>List commits that are present on the current branch and not merged into ref.  A ref can be a branch name or a tag name.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log ref..</span><br></pre></td></tr></table></figure><p>List commit that are present on ref and not merged into current branch.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log ..ref</span><br></pre></td></tr></table></figure><p>List operations (e.g. checkouts or commits) made on local repository</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure><h2 id="07-Tagging-commits"><a href="#07-Tagging-commits" class="headerlink" title="07  Tagging commits"></a>07  Tagging commits</h2><p> List all tags.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag</span><br></pre></td></tr></table></figure><p>Create a tag reference named <strong>[name]</strong> for current commit. Add <strong>commit sha</strong> to tag a specific commit instead of current one</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag [name] [commit sha]</span><br></pre></td></tr></table></figure><p> Create a tag object named <strong>[name]</strong> for current commit.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -a [name] [commit sha]</span><br></pre></td></tr></table></figure><p>Remove a tag from local repository.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -d [name]</span><br></pre></td></tr></table></figure><h2 id="08-Reverting-changes"><a href="#08-Reverting-changes" class="headerlink" title="08  Reverting changes"></a>08  Reverting changes</h2><p>Switches the current branch to the <strong>target reference</strong>, leaving a difference as an uncommitted change. When <strong>–hard</strong> is used, all changes are discarded. It’s easy to lose uncommitted changes with <strong>–hard</strong>.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset [--hard] [target reference]</span><br></pre></td></tr></table></figure><p>Create a new commit, reverting changes from the specified commit. It generates an inversion of changes.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert [commit sha]</span><br></pre></td></tr></table></figure><h2 id="09-Synchronizing-repositories"><a href="#09-Synchronizing-repositories" class="headerlink" title="09  Synchronizing repositories"></a>09  Synchronizing repositories</h2><p>Fetch changes from the <strong>remote</strong>, but not update tracking branches.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch [remote]</span><br></pre></td></tr></table></figure><p>Delete remote Refs that were removed from the <strong>remote</strong> repository</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch --prune [remote]</span><br></pre></td></tr></table></figure><p>Fetch changes from the <strong>remote</strong> and merge current branch with its upstream.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull [remote]</span><br></pre></td></tr></table></figure><p>Push local changes to the <strong>remote</strong>. Use <strong>–tags</strong> to push tags.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push [--tags] [remote]</span><br></pre></td></tr></table></figure><p>Push local branch to remote repository. Set its copy as an upstream.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u [remote] [branch]</span><br></pre></td></tr></table></figure><h2 id="10-Ignoring-files"><a href="#10-Ignoring-files" class="headerlink" title="10  Ignoring files"></a>10  Ignoring files</h2><p>To ignore files, create a .gitignore file in your repository with a line for each pattern. File ignoring will<br>work for the current and sub directories where .gitignore file is placed. In this example, all files are<br>ignored in the logs directory (excluding the .gitkeep file), whole tmp directory and all files *.swp.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt;EOF &gt;  .gitignore</span><br><span class="line">/logs-*</span><br><span class="line">!logs/.gitkeep</span><br><span class="line">/tmp</span><br><span class="line">*.swp</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 通用知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bash Basic CheatSheet</title>
      <link href="//bash-basic-cheatsheet/"/>
      <url>//bash-basic-cheatsheet/</url>
      
        <content type="html"><![CDATA[<h2 id="Bash"><a href="#Bash" class="headerlink" title="Bash"></a>Bash</h2><h3 id="Shebang"><a href="#Shebang" class="headerlink" title="Shebang"></a><strong>Shebang</strong></h3><p>Special comment, specifies that the file is a script and calls a certain interpreter (i.e., bash, sh, python)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/usr/bin/env python</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/usr/bin/python</span></span><br></pre></td></tr></table></figure><h3 id="Comments"><a href="#Comments" class="headerlink" title="Comments"></a><strong>Comments</strong></h3><p>Use a pound&#x2F;sharp&#x2F;hashtag <strong>without a !</strong> to write comments</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">This is a comment</span></span><br></pre></td></tr></table></figure><h2 id="Variables"><a href="#Variables" class="headerlink" title="Variables"></a><strong>Variables</strong></h2><h3 id="shell-variables"><a href="#shell-variables" class="headerlink" title="shell variables"></a><strong>shell variables</strong></h3><ul><li>Whitespace matters!</li><li>Use $VAR to output the value of variable VAR</li><li>Display text with echo</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NAME=&quot;value&quot;</span><br><span class="line">echo &quot;$NAME&quot;</span><br></pre></td></tr></table></figure><ul><li>Types? What types?</li><li>Bash variables are untyped</li><li>Operations are contextual</li><li>Everything is string</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FOO=1</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">FOO + 1</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">error!</span></span><br></pre></td></tr></table></figure><ul><li>Use the expr command to evaluate expressions</li><li>Part of coreutils</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FOO=1</span><br><span class="line">expr $FOO + 1</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h3 id="User-input"><a href="#User-input" class="headerlink" title="User input"></a><strong>User input</strong></h3><ul><li>Use the read command get user input</li><li>“-p” is for the optional prompt</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">read -p &quot;send: &quot; FOO</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">type</span> “hi” and enter</span></span><br><span class="line"></span><br><span class="line">echo &quot;sent: $FOO&quot;</span><br><span class="line">sent: hi</span><br></pre></td></tr></table></figure><h3 id="subshell"><a href="#subshell" class="headerlink" title="subshell"></a><strong>subshell</strong></h3><p>$(<strong>cmd</strong>) evaluates the command <strong>cmd</strong> inside, and substitutes the output into the script.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FOO=$(expr 1 + 1)</span><br><span class="line">echo &quot;$FOO&quot;</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="Conditionals"><a href="#Conditionals" class="headerlink" title="Conditionals"></a><strong>Conditionals</strong></h2><h3 id="test"><a href="#test" class="headerlink" title="test"></a><strong>test</strong></h3><p>conditional checks</p><ul><li>Evaluates an expression. Also synonymous with []</li><li>Sets exit status to <strong>0 (true), 1 (false)</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-eq ==</span><br><span class="line">-ne !=</span><br><span class="line">-gt &gt;</span><br><span class="line">-ge &gt;=</span><br><span class="line">-lt &lt;</span><br><span class="line">-le &lt;=</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">test zero = zero; echo $?</span><br><span class="line">0 # 0 means true</span><br><span class="line">test zero = one; echo $?</span><br><span class="line">1 # 1 means false</span><br></pre></td></tr></table></figure><h3 id="“boolean”-ops"><a href="#“boolean”-ops" class="headerlink" title="“boolean” ops"></a><strong>“boolean” ops</strong></h3><p>&amp;&amp; and || for shell, -a and -o for test&#x2F;[]</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[ 0 -lt 1 ] &amp;&amp; [ 0 -gt 1 ]; echo $?</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">[ 0 -lt 1 -o 0 -gt 1 ]; echo $?</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h3 id="if"><a href="#if" class="headerlink" title="if"></a><strong>if</strong></h3><p>What if…?</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if [ “$1” -eq 79 ];</span><br><span class="line">then</span><br><span class="line">echo “nice”</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h3 id="if-else"><a href="#if-else" class="headerlink" title="if-else"></a><strong>if-else</strong></h3><p>…And what ifn’t</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if [ “$1” -eq 79 ];</span><br><span class="line">then</span><br><span class="line">echo “nice”</span><br><span class="line">else</span><br><span class="line">echo “darn”</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h3 id="elif"><a href="#elif" class="headerlink" title="elif"></a><strong>elif</strong></h3><p>…And what ifn’t but if</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if [ “$1” -eq 79 ];</span><br><span class="line">then</span><br><span class="line">echo “nice”</span><br><span class="line">elif [ “$1” -eq 42 ];</span><br><span class="line">then</span><br><span class="line">echo “the answer!”</span><br><span class="line">else</span><br><span class="line">echo “wat r numbers”</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h3 id="case"><a href="#case" class="headerlink" title="case"></a><strong>case</strong></h3><p>No one likes long if statements…</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">read -p &quot;are you 21?&quot; ANSWER</span><br><span class="line">case &quot;$ANSWER&quot; in</span><br><span class="line">  “yes”)</span><br><span class="line">    echo &quot;i give u cookie&quot;;;</span><br><span class="line">  “no”)</span><br><span class="line">    echo &quot;thats illegal&quot;;;</span><br><span class="line">  “are you?”)</span><br><span class="line">    echo “lets not”;;</span><br><span class="line">  *)</span><br><span class="line">    echo &quot;please answer&quot;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><h2 id="Loops"><a href="#Loops" class="headerlink" title="Loops"></a><strong>Loops</strong></h2><h3 id="for-loops"><a href="#for-loops" class="headerlink" title="for loops"></a><strong>for loops</strong></h3><p>for all your stuff in stuffs</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SHEEP=(&quot;one&quot; &quot;dos&quot; &quot;tre&quot;)</span><br><span class="line">for S in $SHEEP</span><br><span class="line">do</span><br><span class="line">echo &quot;$S sheep...&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>supports ranges too</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">n=0</span><br><span class="line">for x in &#123;1..10&#125;</span><br><span class="line">do</span><br><span class="line">n=$(expr $x + $n)</span><br><span class="line">done</span><br><span class="line">echo $n</span><br></pre></td></tr></table></figure><h3 id="while-loops"><a href="#while-loops" class="headerlink" title="while loops"></a><strong>while loops</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while true</span><br><span class="line">do</span><br><span class="line">echo &quot;nightmare &quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h2 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h2><h3 id="functions"><a href="#functions" class="headerlink" title="functions"></a><strong>functions</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function greet() &#123;</span><br><span class="line">    echo &quot;hey there $1&quot;</span><br><span class="line">&#125;</span><br><span class="line">greet “sysadmin decal”</span><br><span class="line"></span><br><span class="line">hey there sysadmin decal</span><br></pre></td></tr></table></figure><p>script args are stored the same way as with functions</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="keyword">in</span> terminal</span></span><br><span class="line">ls .</span><br><span class="line">b.txt a.txt c.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">script.sh</span></span><br><span class="line">ls $1 | sort</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="keyword">in</span> terminal</span></span><br><span class="line">./script.sh .</span><br><span class="line">a.txt b.txt</span><br><span class="line">c.txt</span><br></pre></td></tr></table></figure><h2 id="Streams"><a href="#Streams" class="headerlink" title="Streams"></a>Streams</h2><h3 id="Redirection"><a href="#Redirection" class="headerlink" title="Redirection"></a><strong>Redirection</strong></h3><p>Use &gt; to output to somewhere else, like a text file!</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;hello&quot; &gt; out.txt</span><br></pre></td></tr></table></figure><p>Use &lt; to take input from a file!</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort &lt; file</span><br></pre></td></tr></table></figure><h3 id="Append"><a href="#Append" class="headerlink" title="Append"></a><strong>Append</strong></h3><p>Use &gt;&gt; to append output to a file. If file is empty, works the same as &gt;</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;hello&quot; &gt;&gt; out.txt</span><br></pre></td></tr></table></figure><h3 id="Pipes"><a href="#Pipes" class="headerlink" title="Pipes"></a><strong>Pipes</strong></h3><p>Take output of first command and “pipe” it into the second one, connecting stdin and stdout</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command1 | command2</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 通用知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CheatSheet </tag>
            
            <tag> shell </tag>
            
            <tag> bash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker Basic CheatSheet</title>
      <link href="//docker-basic-cheatsheet/"/>
      <url>//docker-basic-cheatsheet/</url>
      
        <content type="html"><![CDATA[<h1 id="Basic-Commands"><a href="#Basic-Commands" class="headerlink" title="Basic Commands:"></a><strong>Basic Commands:</strong></h1><h2 id="Container-Lifecycle"><a href="#Container-Lifecycle" class="headerlink" title="Container Lifecycle:"></a><strong>Container Lifecycle:</strong></h2><p>docker run: Create and start a container.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -d -name my_container nginx</span></span><br></pre></td></tr></table></figure><p>docker start&#x2F;stop&#x2F;restart: Start, stop, or restart a container.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker stop my_container</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker start my_container</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker restart my_container</span></span><br></pre></td></tr></table></figure><p>docker ps: List running containers.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker ps</span></span><br></pre></td></tr></table></figure><p>docker ps -a: List all containers (including stopped ones).</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker ps -a</span></span><br></pre></td></tr></table></figure><h2 id="Image-Management"><a href="#Image-Management" class="headerlink" title="Image Management:"></a><strong>Image Management:</strong></h2><p>docker pull: Fetch an image from a registry.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker pull ubuntu</span></span><br></pre></td></tr></table></figure><p>docker build: Build an image from a Dockerfile.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker build -t my_image .</span></span><br></pre></td></tr></table></figure><p>docker images: List all local images.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker images</span></span><br></pre></td></tr></table></figure><p>docker rmi: Remove an image.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker rmi my_image</span></span><br></pre></td></tr></table></figure><h1 id="Container-Operations"><a href="#Container-Operations" class="headerlink" title="Container Operations:"></a><strong>Container Operations:</strong></h1><h2 id="Interacting-with-Containers"><a href="#Interacting-with-Containers" class="headerlink" title="Interacting with Containers:"></a><strong>Interacting with Containers:</strong></h2><p>docker exec: Execute a command in a running container.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker <span class="built_in">exec</span> -it my_container bash</span></span><br></pre></td></tr></table></figure><p>docker attach: Attach to a running container.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker attach my_container</span></span><br></pre></td></tr></table></figure><p>docker logs: View container logs.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker logs my_container</span></span><br></pre></td></tr></table></figure><h2 id="Managing-Container-Resources"><a href="#Managing-Container-Resources" class="headerlink" title="Managing Container Resources:"></a><strong>Managing Container Resources:</strong></h2><p>docker cp: Copy files between container and host.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker <span class="built_in">cp</span> file.txt my_container:/path/to/destination</span></span><br></pre></td></tr></table></figure><p>docker pause&#x2F;unpause: Pause or unpause a running container.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker pause my_container</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker unpause my_container</span></span><br></pre></td></tr></table></figure><p>docker inspect: Display detailed container information.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker inspect my_container</span></span><br></pre></td></tr></table></figure><h1 id="Networking"><a href="#Networking" class="headerlink" title="Networking:"></a><strong>Networking:</strong></h1><h2 id="Networking-1"><a href="#Networking-1" class="headerlink" title="Networking:"></a><strong>Networking:</strong></h2><p>docker network ls: List available networks.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker network <span class="built_in">ls</span></span></span><br></pre></td></tr></table></figure><p>docker network create: Create a new network.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker network create my_network</span></span><br></pre></td></tr></table></figure><p>docker network connect&#x2F;disconnect: Connect or disconnect a container to&#x2F;from a network.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker network connect my_network my_container</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker network disconnect my_network my_container</span></span><br></pre></td></tr></table></figure><h1 id="Volume-Management"><a href="#Volume-Management" class="headerlink" title="Volume Management:"></a><strong>Volume Management:</strong></h1><h2 id="Volumes"><a href="#Volumes" class="headerlink" title="Volumes:"></a><strong>Volumes:</strong></h2><p>docker volume ls: List volumes.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker volume <span class="built_in">ls</span></span></span><br></pre></td></tr></table></figure><p>docker volume create: Create a volume.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker volume create my_volume</span></span><br></pre></td></tr></table></figure><p>docker volume rm: Remove a volume.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker volume <span class="built_in">rm</span> my_volume</span></span><br></pre></td></tr></table></figure><p>docker volume inspect: Display detailed volume information.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker volume inspect my_volume</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 通用知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CheatSheet </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>顺德-流水账</title>
      <link href="//shunde-tour-2024/"/>
      <url>//shunde-tour-2024/</url>
      
        <content type="html"><![CDATA[<p>02&#x2F;05&#x2F;2024 - 02&#x2F;06&#x2F;2024</p><p>高铁先去中山，春运很多人</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/73ebea30-46e7-41a3-9efa-725da4be22e9/17c73baf-3dab-4835-8eff-9270a3ae6c79/Untitled.jpeg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI/20240724/us-west-2/s3/aws4_request&X-Amz-Date=20240724T161259Z&X-Amz-Expires=3600&X-Amz-Signature=00dd74c4997e14c86feec3a921b57255daef162e1694c732cefef14290d3dfbc&X-Amz-SignedHeaders=host&x-id=GetObject" alt="Untitled.jpeg"></p><p>到达小榄</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/73ebea30-46e7-41a3-9efa-725da4be22e9/f678b7ae-d8dd-49cd-a596-600a8a56ee91/Untitled.jpeg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI/20240724/us-west-2/s3/aws4_request&X-Amz-Date=20240724T161258Z&X-Amz-Expires=3600&X-Amz-Signature=2aba0d91530b0e5d5a064a43fa657f805a93e8fe6b85aa2aca57079606c1c881&X-Amz-SignedHeaders=host&x-id=GetObject" alt="Untitled.jpeg"></p><p>红日饭店吃脆肉皖，嘎嘎香</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/73ebea30-46e7-41a3-9efa-725da4be22e9/caf9c1dc-40eb-4e06-b4ba-de436e603e94/Untitled.jpeg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI/20240724/us-west-2/s3/aws4_request&X-Amz-Date=20240724T161258Z&X-Amz-Expires=3600&X-Amz-Signature=488a16b76225f4b96a0073103e3ae90f5d56ff7d859c35692cbbba3dfe85f0d9&X-Amz-SignedHeaders=host&x-id=GetObject" alt="Untitled.jpeg"></p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/73ebea30-46e7-41a3-9efa-725da4be22e9/8a19343e-cef7-45af-8334-e3665070c5c7/Untitled.jpeg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI/20240724/us-west-2/s3/aws4_request&X-Amz-Date=20240724T161259Z&X-Amz-Expires=3600&X-Amz-Signature=96418f65bd078049e66219ed56bb6959b6fe2592e7e85c8bca725b85ef9135d2&X-Amz-SignedHeaders=host&x-id=GetObject" alt="Untitled.jpeg"></p><p>第二天一早出发顺德，先去清晖园边上的香云纱酒店吃个早茶</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/73ebea30-46e7-41a3-9efa-725da4be22e9/dc05e5bb-974f-482c-a05a-b6be9b87be4d/Untitled.jpeg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI/20240724/us-west-2/s3/aws4_request&X-Amz-Date=20240724T161259Z&X-Amz-Expires=3600&X-Amz-Signature=af5e16dd529069acfcd28fd428dff65c61b54d99fcbcfc6ca141aa822f945ce4&X-Amz-SignedHeaders=host&x-id=GetObject" alt="Untitled.jpeg"></p><p>清晖园乱转</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/73ebea30-46e7-41a3-9efa-725da4be22e9/28491947-033f-4199-a52c-9f120517b75b/Untitled.jpeg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI/20240724/us-west-2/s3/aws4_request&X-Amz-Date=20240724T161259Z&X-Amz-Expires=3600&X-Amz-Signature=dde28438d8cc2d010ee7483a9374c07d878a0d98ef88b39daf8dd5f6630e831d&X-Amz-SignedHeaders=host&x-id=GetObject" alt="Untitled.jpeg"></p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/73ebea30-46e7-41a3-9efa-725da4be22e9/93339965-3530-44a7-b801-a76fe7f26c20/Untitled.jpeg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI/20240724/us-west-2/s3/aws4_request&X-Amz-Date=20240724T161259Z&X-Amz-Expires=3600&X-Amz-Signature=724bc7a38bed738984ee5e9d9590a13a52fc74f0968335ae98cd301166b5771c&X-Amz-SignedHeaders=host&x-id=GetObject" alt="Untitled.jpeg"></p><p>中午吃的街边煲仔饭</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/73ebea30-46e7-41a3-9efa-725da4be22e9/83df6e5d-be7c-40b4-a78e-e8cafea81525/Untitled.jpeg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI/20240724/us-west-2/s3/aws4_request&X-Amz-Date=20240724T161259Z&X-Amz-Expires=3600&X-Amz-Signature=d57a4ae5feb2023357a4111ff6768773a4ce6a7d66da29c56cd6a2227f41efb5&X-Amz-SignedHeaders=host&x-id=GetObject" alt="Untitled.jpeg"></p><p>民信双皮奶，味道不错</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/73ebea30-46e7-41a3-9efa-725da4be22e9/1d5ef930-358e-4c2c-a661-6e55e943c5a5/Untitled.jpeg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI/20240724/us-west-2/s3/aws4_request&X-Amz-Date=20240724T161259Z&X-Amz-Expires=3600&X-Amz-Signature=8e82ebcbf47b44a3641905304affcbf3a545f9897b8851e9253718ed36ad5d1e&X-Amz-SignedHeaders=host&x-id=GetObject" alt="Untitled.jpeg"></p><p>华盖山只在山脚下转了转，没往上爬</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/73ebea30-46e7-41a3-9efa-725da4be22e9/26b4ca21-2e40-4f9d-81c6-64e0040088aa/Untitled.jpeg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI/20240724/us-west-2/s3/aws4_request&X-Amz-Date=20240724T161259Z&X-Amz-Expires=3600&X-Amz-Signature=9de118b0b61b52e401ab02392bd56be2153c28fe64107d5891936c8761ad81d1&X-Amz-SignedHeaders=host&x-id=GetObject" alt="Untitled.jpeg"></p><p>去 欢乐海岸plus 乱逛</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/73ebea30-46e7-41a3-9efa-725da4be22e9/b37f0a3f-f1e0-4187-981c-0287bf1bc70c/Untitled.jpeg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI/20240724/us-west-2/s3/aws4_request&X-Amz-Date=20240724T161259Z&X-Amz-Expires=3600&X-Amz-Signature=6880682e8c81c6ea19a10bdf7048ed24049ab1a8b4b7ac3daa23b27e61479625&X-Amz-SignedHeaders=host&x-id=GetObject" alt="Untitled.jpeg"></p><p>柴油机1959创意园也去了</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/73ebea30-46e7-41a3-9efa-725da4be22e9/873bb9ce-4bcb-467b-965a-8667fea90861/Untitled.jpeg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI/20240724/us-west-2/s3/aws4_request&X-Amz-Date=20240724T161300Z&X-Amz-Expires=3600&X-Amz-Signature=6cb39f359a1ff71db8e59dc24c3fbfb918d377395b150fb8c975822551d15b8e&X-Amz-SignedHeaders=host&x-id=GetObject" alt="Untitled.jpeg"></p><p>路边一户人家墙外的画，感觉非常非常的好看</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/73ebea30-46e7-41a3-9efa-725da4be22e9/d86c2b8c-7b93-4ddf-a1a0-bffad5685de7/Untitled.jpeg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI/20240724/us-west-2/s3/aws4_request&X-Amz-Date=20240724T161300Z&X-Amz-Expires=3600&X-Amz-Signature=e1f0a82f82629a37b819d98f7389bb7ef34b3ee371d2a0e76b58c20518f57dcc&X-Amz-SignedHeaders=host&x-id=GetObject" alt="Untitled.jpeg"></p><p>渔人码头也去看看</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/73ebea30-46e7-41a3-9efa-725da4be22e9/1d1cff11-153d-460d-9470-e0f41cb4a90d/Untitled.jpeg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI/20240724/us-west-2/s3/aws4_request&X-Amz-Date=20240724T161259Z&X-Amz-Expires=3600&X-Amz-Signature=8c666114951cdaa8fc2afea4c2391d4f0e69be55d260f9357950a0e13f5d483d&X-Amz-SignedHeaders=host&x-id=GetObject" alt="Untitled.jpeg"></p><p>晚餐是杏坛公粥底火锅，挺实惠的，也挺好吃</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/73ebea30-46e7-41a3-9efa-725da4be22e9/1b6a1a91-8ee7-4e3c-8899-b6ccfadfc057/Untitled.jpeg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI/20240724/us-west-2/s3/aws4_request&X-Amz-Date=20240724T161259Z&X-Amz-Expires=3600&X-Amz-Signature=2457fb0bb0fd34ba28c3e015113009242feda1c50e4dae5c497c23c4f57504e1&X-Amz-SignedHeaders=host&x-id=GetObject" alt="Untitled.jpeg"></p><p>马路边上吃鱼皮</p><p><img src="/images/db79dcfb73dc7dad91715ba3dcff0bad.jpeg" alt="Untitled.jpeg"></p><p>走之前再来一份民信的甜品</p><p><img src="/images/cb6ea5a689f7bd8698c25962ef998864.jpeg" alt="Untitled.jpeg"></p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/73ebea30-46e7-41a3-9efa-725da4be22e9/c1a89146-2a0d-4fd5-a8d8-90e9b2510c0f/Untitled.jpeg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI/20240724/us-west-2/s3/aws4_request&X-Amz-Date=20240724T161258Z&X-Amz-Expires=3600&X-Amz-Signature=2518bd723282b0524852b9a05b520c07e69f2d1f56a105469561bc6f1d99c24d&X-Amz-SignedHeaders=host&x-id=GetObject" alt="Untitled.jpeg"></p>]]></content>
      
      
      <categories>
          
          <category> 出去玩 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 吃 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>长沙-流水账</title>
      <link href="//changsha-tour-2023/"/>
      <url>//changsha-tour-2023/</url>
      
        <content type="html"><![CDATA[<p>10&#x2F;20&#x2F;2023 - 10&#x2F;22&#x2F;2023</p><h2 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h2><p>大晚上睡一觉，硬卧到了</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/73ebea30-46e7-41a3-9efa-725da4be22e9/d92979f4-da19-468c-b3e6-57b10608c7ca/IMG_20231220_064339.jpg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI/20240724/us-west-2/s3/aws4_request&X-Amz-Date=20240724T161302Z&X-Amz-Expires=3600&X-Amz-Signature=d1bcb79771db14d77ba849f5908b44a23d2a277322fabf5239775687bb06dcf1&X-Amz-SignedHeaders=host&x-id=GetObject" alt="IMG_20231220_064339.jpg"></p><p>六点多到的，太早了，长沙还没睡醒</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/73ebea30-46e7-41a3-9efa-725da4be22e9/70cb6a77-3843-4567-bcac-a7106dd974a2/IMG_20231220_064947.jpg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI/20240724/us-west-2/s3/aws4_request&X-Amz-Date=20240724T161304Z&X-Amz-Expires=3600&X-Amz-Signature=a82ccea921f7569aed431b45683a48ac37588ee15805ee1858700fc1770b701e&X-Amz-SignedHeaders=host&x-id=GetObject" alt="IMG_20231220_064947.jpg"></p><p>先恰个粉，卤肉米粉</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/73ebea30-46e7-41a3-9efa-725da4be22e9/2618c73a-d7c5-4fb4-9c48-93fa8647b217/IMG_20231220_072811.jpg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI/20240724/us-west-2/s3/aws4_request&X-Amz-Date=20240724T161304Z&X-Amz-Expires=3600&X-Amz-Signature=c3dec62985d3919e84db311ef9501c4f9eca5e0feb7220033501ad896f6bf1c4&X-Amz-SignedHeaders=host&x-id=GetObject" alt="IMG_20231220_072811.jpg"></p><p>没地方开门了，住宿的地方也还没到能进的时间，开斗！</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/73ebea30-46e7-41a3-9efa-725da4be22e9/64133a25-bcd4-461c-8cee-5b12e4644a58/IMG_20231220_085115.jpg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI/20240724/us-west-2/s3/aws4_request&X-Amz-Date=20240724T161304Z&X-Amz-Expires=3600&X-Amz-Signature=39bd67eb5148d5a22a25fdb16a90296a7b79707d8bb8514a3fc81a5c00c9cbef&X-Amz-SignedHeaders=host&x-id=GetObject" alt="IMG_20231220_085115.jpg"></p><p>终于等到大伙都上班了，茶颜悦色一下</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/73ebea30-46e7-41a3-9efa-725da4be22e9/0962f77f-4527-4228-9a0b-42ee50e8faf2/IMG_20231220_104733.jpg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI/20240724/us-west-2/s3/aws4_request&X-Amz-Date=20240724T161304Z&X-Amz-Expires=3600&X-Amz-Signature=233c8c72f1fa852cac0d417f3421fe67c9ae1a098176bde100317ff5b66db31d&X-Amz-SignedHeaders=host&x-id=GetObject" alt="IMG_20231220_104733.jpg"></p><p>国金中心转了转</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/73ebea30-46e7-41a3-9efa-725da4be22e9/1306ea02-b310-4eca-ab45-ca9ae11539e0/IMG_20231220_111003.jpg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI/20240724/us-west-2/s3/aws4_request&X-Amz-Date=20240724T161303Z&X-Amz-Expires=3600&X-Amz-Signature=1643fcc6b58fb71deb3d36b26cb90035dcd2abeb0a4ed1b5bda8cf6e8f064cba&X-Amz-SignedHeaders=host&x-id=GetObject" alt="IMG_20231220_111003.jpg"></p><p>步行街转了转</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/73ebea30-46e7-41a3-9efa-725da4be22e9/0fd89efd-f34c-41cc-a058-4cac16e5eed8/IMG_20231220_112208.jpg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI/20240724/us-west-2/s3/aws4_request&X-Amz-Date=20240724T161303Z&X-Amz-Expires=3600&X-Amz-Signature=7ca5d3ccbf3ddcac2238dabf86ff56cedea05b53aae5b7fdd3436b8bfd740a4f&X-Amz-SignedHeaders=host&x-id=GetObject" alt="IMG_20231220_112208.jpg"></p><p>午饭笨萝卜，刚好不用排队</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/73ebea30-46e7-41a3-9efa-725da4be22e9/4dda3aa1-9dce-4f54-85e9-47029e8e06fd/IMG_20231220_114143.jpg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI/20240724/us-west-2/s3/aws4_request&X-Amz-Date=20240724T161303Z&X-Amz-Expires=3600&X-Amz-Signature=7f6f065f25edd23163ffe708c0dbb089fd5ad10835ccea3aa69b2447193290e2&X-Amz-SignedHeaders=host&x-id=GetObject" alt="IMG_20231220_114143.jpg"></p><p>下午去橘子洲溜达</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/73ebea30-46e7-41a3-9efa-725da4be22e9/043f7f1e-47a7-4dd4-a524-6a5dda17bc4c/IMG_20231220_152745.jpg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI/20240724/us-west-2/s3/aws4_request&X-Amz-Date=20240724T161303Z&X-Amz-Expires=3600&X-Amz-Signature=73c8fc0c83f9ce97bdeb563617ce45741e861b1be7156fd295623f67e6e0d725&X-Amz-SignedHeaders=host&x-id=GetObject" alt="IMG_20231220_152745.jpg"></p><p>晚上在太平老街吃的公交新村面店</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/73ebea30-46e7-41a3-9efa-725da4be22e9/cc6bda0d-1d99-4085-b1ec-310b1f922df6/IMG_20231220_172309.jpg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI/20240724/us-west-2/s3/aws4_request&X-Amz-Date=20240724T161304Z&X-Amz-Expires=3600&X-Amz-Signature=940a08f4c9a0147ebafbdbcb4e7a34fca7767005ee65b14aa4bcd27230453e44&X-Amz-SignedHeaders=host&x-id=GetObject" alt="IMG_20231220_172309.jpg"></p><p>在街上闲逛一下</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/73ebea30-46e7-41a3-9efa-725da4be22e9/8279014b-f88e-4309-95ec-7c43e069a342/IMG_20231220_181511.jpg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI/20240724/us-west-2/s3/aws4_request&X-Amz-Date=20240724T161303Z&X-Amz-Expires=3600&X-Amz-Signature=d837ec9c20a6fa0dd7525c22248857dd82a58f5b3eb0a62d66f35698a88fb114&X-Amz-SignedHeaders=host&x-id=GetObject" alt="IMG_20231220_181511.jpg"></p><p>喝茶喝茶</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/73ebea30-46e7-41a3-9efa-725da4be22e9/d5bec84f-6f68-4e4a-9dea-0a94064438d1/IMG_20231220_175144.jpg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI/20240724/us-west-2/s3/aws4_request&X-Amz-Date=20240724T161304Z&X-Amz-Expires=3600&X-Amz-Signature=1ac57dd62d53ca86a4ae10029f4ff81aee83faa788b931e77fc2af162488b1ca&X-Amz-SignedHeaders=host&x-id=GetObject" alt="IMG_20231220_175144.jpg"></p><h2 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h2><p>起床恰粉，原汁原味粉面店，唯一不辣的一餐</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/73ebea30-46e7-41a3-9efa-725da4be22e9/49ffe909-3683-4507-9cd9-bd136938e657/IMG_20231221_101750.jpg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI/20240724/us-west-2/s3/aws4_request&X-Amz-Date=20240724T161302Z&X-Amz-Expires=3600&X-Amz-Signature=35822afbeca88f33fa86615ae839aaff1318d7021c051b12e24916d44dd56858&X-Amz-SignedHeaders=host&x-id=GetObject" alt="IMG_20231221_101750.jpg"></p><p>逛了个湖南米粉博物馆</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/73ebea30-46e7-41a3-9efa-725da4be22e9/2c2f41e7-81c3-416d-9a8e-4a949a56a5db/IMG_20231221_103316.jpg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI/20240724/us-west-2/s3/aws4_request&X-Amz-Date=20240724T161302Z&X-Amz-Expires=3600&X-Amz-Signature=704560d0756999ca80a46d2cf967307266a2aacd1305d5e658b8c717efbf9dbc&X-Amz-SignedHeaders=host&x-id=GetObject" alt="IMG_20231221_103316.jpg"></p><p>去了个共产党纪念园</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/73ebea30-46e7-41a3-9efa-725da4be22e9/50bacd43-3acc-4b01-8652-d1e4408be7f2/IMG_20231221_110815.jpg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI/20240724/us-west-2/s3/aws4_request&X-Amz-Date=20240724T161304Z&X-Amz-Expires=3600&X-Amz-Signature=638df5080e40de211b06e17fc5ef969f9cfac5376d4309338f828cb1b7c416d8&X-Amz-SignedHeaders=host&x-id=GetObject" alt="IMG_20231221_110815.jpg"></p><p>再来一杯</p><p><img src="/images/09194749cd759cc9579529694df6123f.jpg" alt="IMG_20231221_121915.jpg"></p><p>又到了愉快的吃饭时间，这次是大碗先生，好便宜</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/73ebea30-46e7-41a3-9efa-725da4be22e9/7262f20e-b501-48d7-bca1-6d2dac91b6d7/IMG_20231221_131507.jpg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI/20240724/us-west-2/s3/aws4_request&X-Amz-Date=20240724T161303Z&X-Amz-Expires=3600&X-Amz-Signature=246e07b9f90828b44cbdad9dc1678314b60c334f2ad1c1702f846d24eb881268&X-Amz-SignedHeaders=host&x-id=GetObject" alt="IMG_20231221_131507.jpg"></p><p>直奔岳麓书院</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/73ebea30-46e7-41a3-9efa-725da4be22e9/e9024ef0-d513-4362-8e05-73123b285ee1/IMG_20231221_142837.jpg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI/20240724/us-west-2/s3/aws4_request&X-Amz-Date=20240724T161304Z&X-Amz-Expires=3600&X-Amz-Signature=2e8fb465ffd88e16a7ad810ff0c5fd98990d97173cc01deab7b557e63224d2af&X-Amz-SignedHeaders=host&x-id=GetObject" alt="IMG_20231221_142837.jpg"></p><p>看了一眼爱晚亭，没去爬山了</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/73ebea30-46e7-41a3-9efa-725da4be22e9/143ba1b2-d550-4a55-9cf6-72f36e49c196/IMG_20231221_154451.jpg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI/20240724/us-west-2/s3/aws4_request&X-Amz-Date=20240724T161304Z&X-Amz-Expires=3600&X-Amz-Signature=9c34a1dafa110053f5a708d2008199aef8b522dd39ce75b07ca3d72f27c7f56b&X-Amz-SignedHeaders=host&x-id=GetObject" alt="IMG_20231221_154451.jpg"></p><p>没爬山，从入口溜了</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/73ebea30-46e7-41a3-9efa-725da4be22e9/f0f52a33-dbf5-4484-ae66-ee14a9386d8c/IMG_20231221_160449.jpg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI/20240724/us-west-2/s3/aws4_request&X-Amz-Date=20240724T161303Z&X-Amz-Expires=3600&X-Amz-Signature=beeea6147e5d7d60ef1c3ae289471a224ab6c6a81da0d207aa47bdda397744e6&X-Amz-SignedHeaders=host&x-id=GetObject" alt="IMG_20231221_160449.jpg"></p><p>溜进湖大转了转</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/73ebea30-46e7-41a3-9efa-725da4be22e9/c04316c3-8958-4d66-bbfb-5ddb48ca4aa3/IMG_20231221_161940.jpg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI/20240724/us-west-2/s3/aws4_request&X-Amz-Date=20240724T161303Z&X-Amz-Expires=3600&X-Amz-Signature=7746856398e0cd1a36b78dc32ea9ae004343a40e5d91666ce5d5af4f2a5ffec5&X-Amz-SignedHeaders=host&x-id=GetObject" alt="IMG_20231221_161940.jpg"></p><p>这边的树真的会黄，好好看</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/73ebea30-46e7-41a3-9efa-725da4be22e9/74b5481f-fc2c-498c-ac96-ce6c49ba5575/IMG_20231221_161235.jpg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI/20240724/us-west-2/s3/aws4_request&X-Amz-Date=20240724T161303Z&X-Amz-Expires=3600&X-Amz-Signature=9e76e510a5632860646d75151188a223b819dea535b4be4083c0206da95d047d&X-Amz-SignedHeaders=host&x-id=GetObject" alt="IMG_20231221_161235.jpg"></p><p>罗森妮娜的奶油号角吃了</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/73ebea30-46e7-41a3-9efa-725da4be22e9/5b6a8615-a9fe-4ab3-8a25-73f2a8371d65/IMG_20231221_173312.jpg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI/20240724/us-west-2/s3/aws4_request&X-Amz-Date=20240724T161303Z&X-Amz-Expires=3600&X-Amz-Signature=d0ead63169f82388e836bafb4455827eaacc0ab44552517b497291d094530174&X-Amz-SignedHeaders=host&x-id=GetObject" alt="IMG_20231221_173312.jpg"></p><p>晚饭吃的这个光头佬家常菜是真的香喷喷，就是位置很偏僻</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/73ebea30-46e7-41a3-9efa-725da4be22e9/39e27ddd-14eb-4e33-9931-69b4795b08ed/IMG_20231221_201602.jpg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI/20240724/us-west-2/s3/aws4_request&X-Amz-Date=20240724T161304Z&X-Amz-Expires=3600&X-Amz-Signature=ee58a6b02d523461d8084fb4502fd221c8d7e8760465ee1b3aab4c092653718b&X-Amz-SignedHeaders=host&x-id=GetObject" alt="IMG_20231221_201602.jpg"></p><p>回去睡觉的路上吃个宵夜</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/73ebea30-46e7-41a3-9efa-725da4be22e9/ba9fc2c5-58a5-4b1f-985e-44365d4c9f1d/IMG_20231221_212946.jpg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI/20240724/us-west-2/s3/aws4_request&X-Amz-Date=20240724T161304Z&X-Amz-Expires=3600&X-Amz-Signature=de683830d1d05773460e96e9ae5a125357e64ec521b2aee182627de1b9a30de7&X-Amz-SignedHeaders=host&x-id=GetObject" alt="IMG_20231221_212946.jpg"></p><h2 id="第三天"><a href="#第三天" class="headerlink" title="第三天"></a>第三天</h2><p>复兴时代广场周边转了转</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/73ebea30-46e7-41a3-9efa-725da4be22e9/fa6ffc6b-e893-4e18-a549-15b0ff380677/IMG_20231222_105007.jpg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI/20240724/us-west-2/s3/aws4_request&X-Amz-Date=20240724T161304Z&X-Amz-Expires=3600&X-Amz-Signature=8f73e8ff6802da3ea66e033ce341ee435cc91781507732f56aeaa651217217e8&X-Amz-SignedHeaders=host&x-id=GetObject" alt="IMG_20231222_105007.jpg"></p><p>没早饭了直接午饭鲁哥饭店，问就是搞太晚了hhh，咸蛋黄茄子很香</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/73ebea30-46e7-41a3-9efa-725da4be22e9/0b7108ca-00e1-4565-a54a-a7980df428f1/IMG_20231222_113120.jpg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI/20240724/us-west-2/s3/aws4_request&X-Amz-Date=20240724T161304Z&X-Amz-Expires=3600&X-Amz-Signature=5ace3a71d7037043c7aa0c1bb1c30ef2ddf2124eff20c2a3173599febe0918cc&X-Amz-SignedHeaders=host&x-id=GetObject" alt="IMG_20231222_113120.jpg"></p><p>湖南省博物馆转了一下午</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/73ebea30-46e7-41a3-9efa-725da4be22e9/28bc2a2f-13b5-4821-b52a-0291a6cbcd5d/IMG_20231222_123440.jpg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI/20240724/us-west-2/s3/aws4_request&X-Amz-Date=20240724T161304Z&X-Amz-Expires=3600&X-Amz-Signature=206977863a2b03f10997b67d61633bc2e43509a2d5352a2e713c955083f775cd&X-Amz-SignedHeaders=host&x-id=GetObject" alt="IMG_20231222_123440.jpg"></p><p>溜了溜了，结束旅程</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/73ebea30-46e7-41a3-9efa-725da4be22e9/9d2262a0-0c40-4b75-a0af-c2f13fd37038/IMG_20231222_194524.jpg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI/20240724/us-west-2/s3/aws4_request&X-Amz-Date=20240724T161304Z&X-Amz-Expires=3600&X-Amz-Signature=7c5f2fe8b672e4d29716e654c85534850557c429cf38bff5534f75f6389de2e8&X-Amz-SignedHeaders=host&x-id=GetObject" alt="IMG_20231222_194524.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 出去玩 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 吃 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sync.Mutex：标准库的互斥锁实现</title>
      <link href="//sync-mutex/"/>
      <url>//sync-mutex/</url>
      
        <content type="html"><![CDATA[<h1 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h1><p>sync.Mutex 是 go 原生提供的互斥锁实现，也是最基本的同步原语了</p><p>合理利用锁即可避免并发编程中由于竞争引发的一些逻辑错误</p><h1 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h1><p>sync.Mutex 对外暴露的接口有三个</p><ol><li>sync.Mutex.Lock 请求锁，如果锁忙，则阻塞。</li><li>sync.Mutex.TryLock 请求锁，如果锁忙则，则返回 false。这是非阻塞的获取锁的方式。</li><li>sync.Mutex.Unlock 释放锁</li></ol><p>一个简单的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> m sync.Mutex</span><br><span class="line">cnt := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">m.Lock()</span><br><span class="line">cnt++</span><br><span class="line">m.Unlock()</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">time.Sleep(time.Second) <span class="comment">// 保证所有协程执行完</span></span><br><span class="line">fmt.Println(cnt)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="核心结构"><a href="#核心结构" class="headerlink" title="核心结构"></a>核心结构</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">state <span class="type">int32</span></span><br><span class="line">sema  <span class="type">uint32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A Locker represents an object that can be locked and unlocked.</span></span><br><span class="line"><span class="keyword">type</span> Locker <span class="keyword">interface</span> &#123;</span><br><span class="line">Lock()</span><br><span class="line">Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一个默认的锁实现 Mutex，而且通过接口提供了扩展性，可以通过实现 Locker 接口，来实现自己的互斥锁。所以使用的时候应该用声明 Locker 接口变量，以后想更改实现就会很容易（虽然一般也不会想着去变）</p><ul><li><p>Mutex.state：表示当前锁的状态，长度是 32 位</p><ul><li>低三位分别表示：锁是空闲还是忙（mutexLocked）、现在阻塞队列头部的 goroutine 正在被唤醒（mutexWoken）、是正常模式还是饥饿模式（mutexStarving）</li><li>剩余 29位用于记录当前互斥锁上等待的 goroutine 的数目（waiterCount）</li></ul><p>  state 这个字段可以说是很省了，是一个 4 合 1 的字段</p></li><li><p>Mutex.sema：控制由于锁而挂起、唤醒的 goroutine 的信号量</p></li></ul><h2 id="主流程"><a href="#主流程" class="headerlink" title="主流程"></a>主流程</h2><h3 id="Mutex-Lock"><a href="#Mutex-Lock" class="headerlink" title="Mutex.Lock"></a>Mutex.Lock</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Lock locks m.</span></span><br><span class="line"><span class="comment">// If the lock is already in use, the calling goroutine</span></span><br><span class="line"><span class="comment">// blocks until the mutex is available.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Lock() &#123;</span><br><span class="line"><span class="comment">// Fast path: grab unlocked mutex.</span></span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, <span class="number">0</span>, mutexLocked) &#123;</span><br><span class="line"><span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">race.Acquire(unsafe.Pointer(m))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Slow path (outlined so that the fast path can be inlined)</span></span><br><span class="line">m.lockSlow()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>先用 atomic 原子操作，用 CAS 操作试探抢锁，抢锁成功就直接返回</li><li>抢锁失败了进入 lockSlow 方法做进一步处理</li></ol><p>这里单独提取了 lockSlow 方法和之前看过的 sync.Once 里面的操作一模一样，就是为了简化 Lock 函数体，Lock 的 fast-path 部分可以内联优化，这个操作在标准库中应用挺多的</p><h3 id="Mutex-lockSlow"><a href="#Mutex-lockSlow" class="headerlink" title="Mutex.lockSlow"></a>Mutex.lockSlow</h3><p>这块逻辑挺长的，先看一下这里的关键概念是锁的模式：正常 or 饥饿</p><p>正常模式下，新 goroutine 和新唤醒的 goroutine 有同样的资格去自旋抢锁，这里可能出现的问题是新 goroutine 往往是更加活跃的它更可能占据着 cpu 所以取锁的概率会相对更高；为了避免等待队列中的 goroutine 迟迟取不到锁，所以当有 goroutine 等待取锁的时间过长，锁会进入饥饿模式，此时所有 goroutine 按照先来后到的顺序依次进入阻塞队列排队取锁</p><p>这里列出源码并添加了详细的注释：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> lockSlow() &#123;</span><br><span class="line"><span class="keyword">var</span> waitStartTime <span class="type">int64</span>  <span class="comment">// 等待时间</span></span><br><span class="line">starving := <span class="literal">false</span>  <span class="comment">// 是否为饥饿模式</span></span><br><span class="line">awoke := <span class="literal">false</span>  <span class="comment">// 阻塞队列队头的 goroutine 是否已经唤醒</span></span><br><span class="line">iter := <span class="number">0</span>  <span class="comment">// 自旋次数</span></span><br><span class="line">old := m.state  <span class="comment">// 临时保存原值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">// [自旋]</span></span><br><span class="line"><span class="comment">// Don&#x27;t spin in starvation mode, ownership is handed off to waiters</span></span><br><span class="line"><span class="comment">// so we won&#x27;t be able to acquire the mutex anyway.</span></span><br><span class="line"><span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == mutexLocked &amp;&amp; runtime_canSpin(iter) &#123;</span><br><span class="line"><span class="comment">// 当前 goroutine 是被重新唤醒的</span></span><br><span class="line"><span class="comment">// 设置锁的 mutexWoken 位</span></span><br><span class="line"><span class="comment">// 避免 unlock 又继续唤醒阻塞队列队头的 goroutine</span></span><br><span class="line"><span class="comment">// Active spinning makes sense.</span></span><br><span class="line"><span class="comment">// Try to set mutexWoken flag to inform Unlock</span></span><br><span class="line"><span class="comment">// to not wake other blocked goroutines.</span></span><br><span class="line"><span class="keyword">if</span> !awoke &amp;&amp; old&amp;mutexWoken == <span class="number">0</span> &amp;&amp; old&gt;&gt;mutexWaiterShift != <span class="number">0</span> &amp;&amp;</span><br><span class="line">atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) &#123;</span><br><span class="line">awoke = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">runtime_doSpin()</span><br><span class="line">iter++</span><br><span class="line">old = m.state</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [构造新 state 值]</span></span><br><span class="line"><span class="built_in">new</span> := old</span><br><span class="line"><span class="comment">// 构造新的 mutexLocked</span></span><br><span class="line"><span class="comment">// 是否要参与抢锁：锁是空闲状态 + 非饥饿模式 才有资格去抢</span></span><br><span class="line"><span class="comment">// Don&#x27;t try to acquire starving mutex, new arriving goroutines must queue.</span></span><br><span class="line"><span class="keyword">if</span> old&amp;mutexStarving == <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">new</span> |= mutexLocked</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 构造新的 waiterCount</span></span><br><span class="line"><span class="comment">// 如果当前协程没有资格抢锁, 则等待拿锁的协程数一定+1</span></span><br><span class="line"><span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) != <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">new</span> += <span class="number">1</span> &lt;&lt; mutexWaiterShift</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正常/饥饿模式的标志位更新</span></span><br><span class="line"><span class="comment">// The current goroutine switches mutex to starvation mode.</span></span><br><span class="line"><span class="comment">// But if the mutex is currently unlocked, don&#x27;t do the switch.</span></span><br><span class="line"><span class="comment">// Unlock expects that starving mutex has waiters, which will not</span></span><br><span class="line"><span class="comment">// be true in this case.</span></span><br><span class="line"><span class="keyword">if</span> starving &amp;&amp; old&amp;mutexLocked != <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">new</span> |= mutexStarving</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 更新的标记位记录：是否有重新被唤醒的 goroutine 正在运行</span></span><br><span class="line"><span class="comment">// 清除掉标记, </span></span><br><span class="line"><span class="keyword">if</span> awoke &#123;</span><br><span class="line"><span class="comment">// The goroutine has been woken from sleep,</span></span><br><span class="line"><span class="comment">// so we need to reset the flag in either case.</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexWoken == <span class="number">0</span> &#123;</span><br><span class="line">throw(<span class="string">&quot;sync: inconsistent mutex state&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">new</span> &amp;^= mutexWoken</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [试图更新 state]</span></span><br><span class="line"><span class="comment">// 基于 old state 构造出的 new state 才能更新 old state</span></span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;</span><br><span class="line"><span class="comment">// [上锁成功]</span></span><br><span class="line"><span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">break</span> <span class="comment">// locked the mutex with CAS</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [准备将协程挂起]</span></span><br><span class="line"><span class="comment">// 老协程放在 queueLifo 队头, 优先取锁</span></span><br><span class="line"><span class="comment">// 新协程放在 queueLifo 队尾, 排队取锁</span></span><br><span class="line"><span class="comment">// If we were already waiting before, queue at the front of the queue.</span></span><br><span class="line">queueLifo := waitStartTime != <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> waitStartTime == <span class="number">0</span> &#123;</span><br><span class="line">waitStartTime = runtime_nanotime()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [挂起协程, 协程进入阻塞队列等待唤醒]</span></span><br><span class="line"><span class="comment">// unlock 解锁的时候会唤醒</span></span><br><span class="line">runtime_SemacquireMutex(&amp;m.sema, queueLifo, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// [队头协程被重新唤醒]</span></span><br><span class="line"><span class="comment">// 等待时间超限就会进入饥饿模式</span></span><br><span class="line">starving = starving || runtime_nanotime()-waitStartTime &gt; starvationThresholdNs</span><br><span class="line">old = m.state</span><br><span class="line"><span class="comment">// [上锁成功]</span></span><br><span class="line"><span class="comment">// 锁已处于饥饿模式, queueLifo 队头协程会直接获得锁, 因为此时不允许自旋的协程竞争</span></span><br><span class="line"><span class="keyword">if</span> old&amp;mutexStarving != <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// If this goroutine was woken and mutex is in starvation mode,</span></span><br><span class="line"><span class="comment">// ownership was handed off to us but mutex is in somewhat</span></span><br><span class="line"><span class="comment">// inconsistent state: mutexLocked is not set and we are still</span></span><br><span class="line"><span class="comment">// accounted as waiter. Fix that.</span></span><br><span class="line"><span class="keyword">if</span> old&amp;(mutexLocked|mutexWoken) != <span class="number">0</span> || old&gt;&gt;mutexWaiterShift == <span class="number">0</span> &#123;</span><br><span class="line">throw(<span class="string">&quot;sync: inconsistent mutex state&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">delta := <span class="type">int32</span>(mutexLocked - <span class="number">1</span>&lt;&lt;mutexWaiterShift)</span><br><span class="line"><span class="comment">// 发现自己是 queueLifo 中最后一个协程并且现在处于饥饿模式</span></span><br><span class="line"><span class="comment">// 则恢复正常模式</span></span><br><span class="line"><span class="keyword">if</span> !starving || old&gt;&gt;mutexWaiterShift == <span class="number">1</span> &#123;</span><br><span class="line"><span class="comment">// Exit starvation mode.</span></span><br><span class="line"><span class="comment">// Critical to do it here and consider wait time.</span></span><br><span class="line"><span class="comment">// Starvation mode is so inefficient, that two goroutines</span></span><br><span class="line"><span class="comment">// can go lock-step infinitely once they switch mutex</span></span><br><span class="line"><span class="comment">// to starvation mode.</span></span><br><span class="line">delta -= mutexStarving</span><br><span class="line">&#125;</span><br><span class="line">atomic.AddInt32(&amp;m.state, delta)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 锁处于正常模式, queueLifo 队头协程需要和新协程一起自旋竞争锁</span></span><br><span class="line">awoke = <span class="literal">true</span></span><br><span class="line">iter = <span class="number">0</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// [尝试更新 state 失败, 从头开始重试自旋抢锁]</span></span><br><span class="line">old = m.state</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">race.Acquire(unsafe.Pointer(m))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 lockSlow 的逻辑还是比较复杂的，大体的逻辑如下：</p><ol><li><p>判断当前情况下能否进入自旋</p><ul><li>条件一：正常模式</li><li>条件二：runtime_canSpin(iter)返回值为 true ，查看函数实现可以知道需要同时满足<ol><li>当前互斥锁处于正常模式</li><li>当前运行的机器是多核CPU，且GOMAXPROCS&gt;1</li><li>至少存在一个其他正在运行的处理器P，并且它的本地运行队列（local runq）为空</li><li>当前goroutine进行自旋的次数小于4</li></ol></li></ul><p> 如果能进入自旋，则通过循环的方式自旋请求锁，否则直接跳过这一阶段</p></li><li><p>计算互斥锁的新状态：mutexLocked、mutexWoken、mutexStarving</p></li><li><p>尝试更新互斥锁的状态<br>如果 2 中计算 state 表明有资格进行抢锁（new state 中 mutexLocked 位是 1），更新这一步就相当于用 CAS 尝试获得锁，如果成功直接返回，失败获取现在 mutex 的状态并回到 1</p><p> 如果 2 中计算 state 表面没有资格进行锁争抢（因为锁已经被其他 goroutine 获取或是此时锁已经处于饥饿模式），则会进入阻塞队列进行等待。新 goroutine 会被放入阻塞队列尾部，已经被唤醒过但是还是没抢到锁的 goroutine 会放到阻塞队列的头部</p><p> 阻塞队列头部的 goroutine 会因为锁的释放操作而被唤醒，如果唤醒时发现锁已经处于了饥饿模式，那么就能直接获取到锁，如果锁此时处于正常模式，则需要回到 1 中和新 goroutine 一起自旋抢锁</p></li></ol><p>这个部分应该就是 mutex 里最复杂的部分了，总结成流程图如下：</p><p><img src="/images/6ed05d4f1d4bb6291b68327579e40551.png" alt="Untitled.png"></p><p>额外总结一下 mutex 的饥饿模式和正常模式：</p><ul><li>饥饿模式是为了避免大量新的请求互斥锁的 goroutine 的出现导致大量自旋，让进入等待队列的 goroutine 一直抢不到锁引发饥饿的问题</li><li>正常模式下，新的请求互斥锁的 goroutine 可以通过自旋等待锁的释放，如此可以避免 goroutine 的切换来提高总体的执行效率</li><li>饥饿模式下，新的请求互斥锁的 goroutine 不允许自旋，直接加入等待队列，按照先来后到取锁</li><li>等待队列中 goroutine 的唤醒是严格按照 FIFO 来唤醒挂起的</li><li>进入饥饿模式的条件为：请求锁的等待时间超过 1ms</li><li>退出饥饿模式的条件为：等待队列为空 或 请求锁的等待时间小于 1ms</li></ul><h3 id="Mutex-Unlock"><a href="#Mutex-Unlock" class="headerlink" title="Mutex.Unlock"></a>Mutex.Unlock</h3><p>Mutex.Unlock 方法用于释放锁，主干仍然是十分简单，细节都在 unlockSlow 这个辅助函数里</p><ol><li>atomic.AddInt32(&amp;m.state, -mutexLocked) 尝试快速解锁</li><li>快速解锁失败则调用 m.unlockSlow(new) 慢速解锁</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unlock unlocks m.</span></span><br><span class="line"><span class="comment">// It is a run-time error if m is not locked on entry to Unlock.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// A locked Mutex is not associated with a particular goroutine.</span></span><br><span class="line"><span class="comment">// It is allowed for one goroutine to lock a Mutex and then</span></span><br><span class="line"><span class="comment">// arrange for another goroutine to unlock it.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Unlock() &#123;</span><br><span class="line"><span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">_ = m.state</span><br><span class="line">race.Release(unsafe.Pointer(m))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fast path: drop lock bit.</span></span><br><span class="line"><span class="built_in">new</span> := atomic.AddInt32(&amp;m.state, -mutexLocked)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">new</span> != <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// Outlined slow path to allow inlining the fast path.</span></span><br><span class="line"><span class="comment">// To hide unlockSlow during tracing we skip one extra frame when tracing GoUnblock.</span></span><br><span class="line">m.unlockSlow(<span class="built_in">new</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Mutex-unlockSlow"><a href="#Mutex-unlockSlow" class="headerlink" title="Mutex.unlockSlow"></a>Mutex.unlockSlow</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> unlockSlow(<span class="built_in">new</span> <span class="type">int32</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">new</span>+mutexLocked)&amp;mutexLocked == <span class="number">0</span> &#123;</span><br><span class="line">fatal(<span class="string">&quot;sync: unlock of unlocked mutex&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexStarving == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 正常模式的处理方法</span></span><br><span class="line">old := <span class="built_in">new</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">// 如果锁没有waiter,或者锁有其他以下已发生的情况之一，则后面的工作就不用做了，直接返回</span></span><br><span class="line">      <span class="comment">// 1. 锁处于锁定状态，表示锁已经被其他 goroutine 获取了</span></span><br><span class="line">      <span class="comment">// 2. 锁处于被唤醒状态，这表明有阻塞队列队头goroutine被唤醒，不用再尝试唤醒其他goroutine</span></span><br><span class="line">      <span class="comment">// 3. 锁处于饥饿模式，那么锁之后会被直接交给等待队列队头goroutine</span></span><br><span class="line"><span class="comment">// If there are no waiters or a goroutine has already</span></span><br><span class="line"><span class="comment">// been woken or grabbed the lock, no need to wake anyone.</span></span><br><span class="line"><span class="comment">// In starvation mode ownership is directly handed off from unlocking</span></span><br><span class="line"><span class="comment">// goroutine to the next waiter. We are not part of this chain,</span></span><br><span class="line"><span class="comment">// since we did not observe mutexStarving when we unlocked the mutex above.</span></span><br><span class="line"><span class="comment">// So get off the way.</span></span><br><span class="line"><span class="keyword">if</span> old&gt;&gt;mutexWaiterShift == <span class="number">0</span> || old&amp;(mutexLocked|mutexWoken|mutexStarving) != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 减少等待的 gorouttine 数目并唤醒阻塞队列队头的 goroutine</span></span><br><span class="line"><span class="comment">// Grab the right to wake someone.</span></span><br><span class="line"><span class="built_in">new</span> = (old - <span class="number">1</span>&lt;&lt;mutexWaiterShift) | mutexWoken</span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;</span><br><span class="line">runtime_Semrelease(&amp;m.sema, <span class="literal">false</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">old = m.state</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 饥饿模式的处理方法</span></span><br><span class="line"><span class="comment">// 直接唤醒阻塞队列中的下一个 goroutine</span></span><br><span class="line"><span class="comment">// Starving mode: handoff mutex ownership to the next waiter, and yield</span></span><br><span class="line"><span class="comment">// our time slice so that the next waiter can start to run immediately.</span></span><br><span class="line"><span class="comment">// Note: mutexLocked is not set, the waiter will set it after wakeup.</span></span><br><span class="line"><span class="comment">// But mutex is still considered locked if mutexStarving is set,</span></span><br><span class="line"><span class="comment">// so new coming goroutines won&#x27;t acquire it.</span></span><br><span class="line">runtime_Semrelease(&amp;m.sema, <span class="literal">true</span>, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面就进入 unlockSlow 部分了,这个相对而言也并不复杂</p><p>正常模式：</p><ul><li>如果没有等待者，或者state低三位不全为0，那就不用唤醒等待队列中的 goroutine</li><li>如果有等待者，就将锁设置为 unlock 并唤醒阻塞队列队头的 goroutine</li></ul><p>饥饿模式：</p><ul><li>直接唤醒等待队列中的下一个 goroutine 即可</li></ul><h2 id="其他内容"><a href="#其他内容" class="headerlink" title="其他内容"></a>其他内容</h2><h3 id="Mutex-TryLock"><a href="#Mutex-TryLock" class="headerlink" title="Mutex.TryLock"></a>Mutex.TryLock</h3><p>源码 + 注释如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TryLock tries to lock m and reports whether it succeeded.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Note that while correct uses of TryLock do exist, they are rare,</span></span><br><span class="line"><span class="comment">// and use of TryLock is often a sign of a deeper problem</span></span><br><span class="line"><span class="comment">// in a particular use of mutexes.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> TryLock() <span class="type">bool</span> &#123;</span><br><span class="line">old := m.state</span><br><span class="line"></span><br><span class="line"><span class="comment">// 看看有没有拿锁的条件</span></span><br><span class="line"><span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试拿锁</span></span><br><span class="line"><span class="comment">// There may be a goroutine waiting for the mutex, but we are</span></span><br><span class="line"><span class="comment">// running now and can try to grab the mutex before that</span></span><br><span class="line"><span class="comment">// goroutine wakes up.</span></span><br><span class="line"><span class="keyword">if</span> !atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexLocked) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">race.Acquire(unsafe.Pointer(m))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是把 Lock 的 slow-path 给去掉了，变成一个非阻塞的方法</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>go 标准库中的 sync.Mutex 实现综合了自旋锁和互斥锁，先尝试自旋，如果能自旋拿到锁，就不用切换 goroutine 了，这样更加高效；如果长时间自旋，就是浪费 cpu 资源，所以多次尝试无果后会将想要拿锁的 goroutine 放到阻塞队列中挂起，当锁被释放时再将位于阻塞队列队头的 goroutine 唤醒</p><p>为了避免阻塞队列中挂起的 goroutine 长时间得不到运行，所以锁会有正常模式和饥饿模式。有 goroutine 长时间得不到运行时锁进入饥饿模式，不允许自旋抢锁，所有 goroutine 依据阻塞队列中的次序依次取锁，以这种方式解决饥饿问题</p><p>从 sync.Mutex 带有自旋的设计而言，如果我们通过 sync.Mutex 只锁定执行耗时很低的关键代码，例如锁定某个变量的赋值，性能是非常不错的（因为等待锁的goroutine不用被挂起，持有锁的goroutine会很快释放锁）。<strong>所以，我们在使用互斥锁时，应该只锁定真正的临界区</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 源码学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sync.Once: 执行且仅仅执行一次动作</title>
      <link href="//sync-once/"/>
      <url>//sync-once/</url>
      
        <content type="html"><![CDATA[<h1 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h1><p>sync.Once 是 Go 语言中的一种同步原语，用于确保某个操作或函数在并发环境下只被执行一次。</p><p>它只有一个导出的方法，即 Do，该方法接收一个函数参数。在 Do 方法被调用后，该函数将被执行，而且只会执行一次，即使在多个协程同时调用的情况下也是如此。</p><h1 id="解决了什么问题"><a href="#解决了什么问题" class="headerlink" title="解决了什么问题"></a>解决了什么问题</h1><p>对于同一个 sync.Once 实例，可以确保通过调用 Do 执行传入 Do 中的方法，执行且仅执行一次</p><p>主要用于以下场景</p><ul><li>单例模式：确保全局只有一个实例对象，避免重复创建资源</li><li>延迟初始化：在程序运行过程中需要用到某个资源时，通过 sync.Once 动态地初始化该资源</li><li>只执行一次的操作：例如只需要执行一次的配置加载、数据清理等操作</li></ul><h1 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h1><p>创建和使用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">once := sync.Once&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(time.Second * <span class="number">3</span>)</span><br><span class="line"><span class="comment">// hello 只会打印一次</span></span><br></pre></td></tr></table></figure><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>代码量很少很少啦</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Once <span class="keyword">struct</span> &#123;</span><br><span class="line">done <span class="type">uint32</span></span><br><span class="line">m    Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span></span> Do(f <span class="function"><span class="keyword">func</span><span class="params">()</span></span>) &#123;</span><br><span class="line"><span class="keyword">if</span> atomic.LoadUint32(&amp;o.done) == <span class="number">0</span> &#123;</span><br><span class="line">o.doSlow(f)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span></span> doSlow(f <span class="function"><span class="keyword">func</span><span class="params">()</span></span>) &#123;</span><br><span class="line">o.m.Lock()</span><br><span class="line"><span class="keyword">defer</span> o.m.Unlock()</span><br><span class="line"><span class="keyword">if</span> o.done == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">defer</span> atomic.StoreUint32(&amp;o.done, <span class="number">1</span>)</span><br><span class="line">f()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sync.Once 使用变量 done 来记录函数的执行状态，使用 <code>sync.Mutex</code> 和 <code>sync.atomic</code> 来保证线程安全的读取 done </p><ul><li>Do 方法通过原子操作 <code>sync.atomic</code> 读取 done，判断函数是否触发过，未触发才继续往下走，调用 doSlow 方法</li><li>doSlow 全局上锁保证同时只有一个 goroutine 能进入，取锁成功后对 done 做第二次校验，避免并发问题。如果 done 的值仍为 0，证明 f 函数没有被执行过，此时执行 f 函数，最后通过原子操作 <code>atomic.StoreUint32</code> 将 done 变量的值设置为 1</li></ul><h2 id="一些-Q-A"><a href="#一些-Q-A" class="headerlink" title="一些 Q&amp;A"></a>一些 Q&amp;A</h2><h3 id="为什么要使用-atomic-原子操作来对于-done-进行读写"><a href="#为什么要使用-atomic-原子操作来对于-done-进行读写" class="headerlink" title="为什么要使用 atomic 原子操作来对于 done 进行读写"></a>为什么要使用 atomic 原子操作来对于 done 进行读写</h3><p>直观的来看，就是 done 变量在 Do 方法中是没有被 sync.Mutex 保护的，如果使用<code>o.done == 0</code>和 <code>o.done = 1</code>来替代<code>atomic.LoadUint32(&amp;o.done) == 0</code> 和 <code>atomic.StoreUint32(&amp;o.done, 1)</code> 会导致并发读写冲突，这肯定是不好的</p><p>p.s. 类似的竞态冲突都可以通过编译时加入 <code>-race</code> 参数被检测出来，这是检查并发问题的好工具</p><p>这会导致出现对于 done 的读取产生不确定的结果</p><p>在执行原子期间，其他 goroutine 无法修改 o.done 的值，因此不会产生竞争条件</p><p>这里其实我感觉如果不用 atomic 原子指令的话其实道理上也许也是能保证程序的正常运行的</p><ol><li>double check 能确保 <code>f()</code>一定只会执行一遍所以能保证功能不出错，所以即使判断出错，也就是有更多的 goroutine 进入 doSlow 在功能层面也没事</li><li>done 变量就是个布尔值不复杂，读不出什么异常值</li></ol><p>但是使用 atomic 确保没有安全问题肯定是更好的选择</p><h3 id="为什么会单独封装一个-doSlow-方法"><a href="#为什么会单独封装一个-doSlow-方法" class="headerlink" title="为什么会单独封装一个 doSlow 方法"></a><strong>为什么会单独封装一个 doSlow 方法</strong></h3><p>将慢路径（slow-path）代码从 Do 方法中分离出来，使得 Do 方法的快路径（fast-path）函数体很小，能够被内联，从而提高性能</p><h3 id="为什么要-double-check"><a href="#为什么要-double-check" class="headerlink" title="为什么要 double check"></a><strong>为什么要 double check</strong></h3><p>第一次检查：避免不必要的锁竞争</p><p>第二次检查：确保 <code>f()</code> 真的只会执行一次</p><p><code>atomic.LoadUint32(&amp;o.done) == 0</code> 为真时，可能会有多个 goroutine 进入 doSlow 方法，我们需要确保 <code>f()</code> 执行完毕后，其他 goroutine 拿到锁进入临界区后不要再执行 <code>f()</code> 了，所以需要再检查一次 done 变量</p><h3 id="为什么不能优化成仅使用-atomic-flag-的实现"><a href="#为什么不能优化成仅使用-atomic-flag-的实现" class="headerlink" title="为什么不能优化成仅使用 atomic + flag 的实现"></a>为什么不能优化成仅使用 atomic + flag 的实现</h3><p>例如优化成如下代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Once <span class="keyword">struct</span> &#123;</span><br><span class="line">done <span class="type">uint32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span></span> Do(f <span class="function"><span class="keyword">func</span><span class="params">()</span></span>) &#123;</span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapUint32(&amp;o.done, <span class="number">0</span>, <span class="number">1</span>) &#123;</span><br><span class="line">f()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>atomic.CompareAndSwapUint32</code> 这个指令完全同时能完成原子性的取值判断和修改操作，这样实现可以省去一个比较重的 <code>sync.Mutex</code> 互斥锁</p><p>这是源码注释中提到的一个问题，说是国外的网友问太多了，就专门加了一段注释</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Note: Here is an incorrect implementation of Do:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//if atomic.CompareAndSwapUint32(&amp;o.done, 0, 1) &#123;</span></span><br><span class="line"><span class="comment">//f()</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Do guarantees that when it returns, f has finished.</span></span><br><span class="line"><span class="comment">// This implementation would not implement that guarantee:</span></span><br><span class="line"><span class="comment">// given two simultaneous calls, the winner of the cas would</span></span><br><span class="line"><span class="comment">// call f, and the second would return immediately, without</span></span><br><span class="line"><span class="comment">// waiting for the first&#x27;s call to f to complete.</span></span><br><span class="line"><span class="comment">// This is why the slow path falls back to a mutex, and why</span></span><br><span class="line"><span class="comment">// the atomic.StoreUint32 must be delayed until after f returns.</span></span><br></pre></td></tr></table></figure><p>关键在于并发的goroutine在调用 Do 方法时，当 Do 方法返回时，我们期望的是初始化函数 f 要执行完毕，但是这个实现第一个 goroutine 在使用 f 进行初始化时，后续并发的 goroutine 会立即返回，尽管f还没有执行完</p><p>这带来的一个问题就是：后续的 goroutine 由于在 f 未执行完就先返回了，在他们的视角里资源是初始化完成了，所以在使用这些未初始化的资源的时候，会出现意想不到的问题，比如 panic 等</p><p>所以不能这么简单的实现</p><h3 id="为什么不在-f-后面-直接-atomic-StoreUint32-o-done-1-而用-defer"><a href="#为什么不在-f-后面-直接-atomic-StoreUint32-o-done-1-而用-defer" class="headerlink" title="为什么不在 f() 后面 直接 atomic.StoreUint32(&amp;o.done, 1) 而用 defer"></a>为什么不在 f() 后面 直接 atomic.StoreUint32(&amp;o.done, 1) 而用 defer</h3><p>考虑 f() 中出现了 panic 的情况，即使程序在外层 recover 回来了，doSlow 也会因此直接返回了，后续的<code>atomic.StoreUint32(&amp;o.done, 1)</code> 在这种情况下就不会得到执行</p><p>即使 f() 没有运行成功，也应当认为 f() 已经运行过了</p><p>使用 defer 能保证如果程序 recover 回来了，那么<code>atomic.StoreUint32(&amp;o.done, 1)</code> 就会得到执行， Once 会说：<code>f()</code> 已经运行过了</p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul><li>在 sync.Once 的 Do 方法中重复调用 Do 方法，在首次调用时会导致死锁。因为内外两层 Do 方法都要抢锁，sync.Mutex 又是个不可重入锁，就形成了循环等待</li><li>如果要传递 sync.Once 变量，要用指针传递而不是值拷贝，不然将 once 值拷贝有可能会导致 once 会重复执行的问题</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>项目文档：<a href="https://pkg.go.dev/sync#Once">https://pkg.go.dev/sync#Once</a></li><li><a href="https://zhuanlan.zhihu.com/p/623090559">Go sync.Once：简约而不简单的并发利器 - 知乎 (zhihu.com)</a></li><li><a href="https://colobu.com/2021/05/05/triple-gates-of-sync-Once/">Go sync.Once的三重门 (colobu.com)</a></li><li><a href="https://go.dev/ref/mem">The Go Memory Model - The Go Programming Language</a></li><li><a href="https://segmentfault.com/a/1190000039729417">后端 - go语言happens-before原则及应用 - 个人文章 - SegmentFault 思否</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 源码学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lumberjack: 滚动日志源码走读</title>
      <link href="//lumberjack/"/>
      <url>//lumberjack/</url>
      
        <content type="html"><![CDATA[<h1 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h1><p>Lumberjack 是一个用于将日志写入滚动文件的 Go 包，旨在成为日志系统基础设施的一部分。它不是一个一体化的解决方案，而是日志记录堆栈底部的一个可插入组件，仅控制写入日志的文件。</p><h1 id="解决了什么问题"><a href="#解决了什么问题" class="headerlink" title="解决了什么问题"></a>解决了什么问题</h1><ul><li>无侵入式的日志切割</li><li>关注点分离：只关注日志的文件管理</li></ul><h1 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">log.SetOutput(&amp;lumberjack.Logger&#123;</span><br><span class="line">    Filename:   <span class="string">&quot;/var/log/myapp/foo.log&quot;</span>,</span><br><span class="line">    MaxSize:    <span class="number">500</span>, <span class="comment">// megabytes</span></span><br><span class="line">    MaxBackups: <span class="number">3</span>,</span><br><span class="line">    MaxAge:     <span class="number">28</span>, <span class="comment">//days</span></span><br><span class="line">    Compress:   <span class="literal">true</span>, <span class="comment">// disabled by default</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>只需使用 <code>*lumberjack.Looger</code> 结构作为 <code>io.WriteCloser</code> 的实现替代例如 <code>os.File</code> 结构等，传入各类日志 logger 的配置中作为输出目标，即可<strong>将日志写入滚动文件</strong></p><ul><li>日志文件分割：日志文件大小超过限制，将日志归档并创建新日志文件</li><li>日志文件清理：旧日志数目超过限制，按时间对日志进行清理</li><li>日志文件压缩：旧日志压缩</li></ul><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="核心结构"><a href="#核心结构" class="headerlink" title="核心结构"></a>核心结构</h2><h3 id="lumberjack-Logger"><a href="#lumberjack-Logger" class="headerlink" title="lumberjack.Logger"></a>lumberjack.Logger</h3><p>唯一暴露在外的结构 Logger，作为<code>io.WriteCloser</code> 接口的实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Logger <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// Filename is the file to write logs to.  Backup log files will be retained</span></span><br><span class="line"><span class="comment">// in the same directory.  It uses &lt;processname&gt;-lumberjack.log in</span></span><br><span class="line"><span class="comment">// os.TempDir() if empty.</span></span><br><span class="line">Filename <span class="type">string</span> <span class="string">`json:&quot;filename&quot; yaml:&quot;filename&quot;`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// MaxSize is the maximum size in megabytes of the log file before it gets</span></span><br><span class="line"><span class="comment">// rotated. It defaults to 100 megabytes.</span></span><br><span class="line">MaxSize <span class="type">int</span> <span class="string">`json:&quot;maxsize&quot; yaml:&quot;maxsize&quot;`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// MaxAge is the maximum number of days to retain old log files based on the</span></span><br><span class="line"><span class="comment">// timestamp encoded in their filename.  Note that a day is defined as 24</span></span><br><span class="line"><span class="comment">// hours and may not exactly correspond to calendar days due to daylight</span></span><br><span class="line"><span class="comment">// savings, leap seconds, etc. The default is not to remove old log files</span></span><br><span class="line"><span class="comment">// based on age.</span></span><br><span class="line">MaxAge <span class="type">int</span> <span class="string">`json:&quot;maxage&quot; yaml:&quot;maxage&quot;`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// MaxBackups is the maximum number of old log files to retain.  The default</span></span><br><span class="line"><span class="comment">// is to retain all old log files (though MaxAge may still cause them to get</span></span><br><span class="line"><span class="comment">// deleted.)</span></span><br><span class="line">MaxBackups <span class="type">int</span> <span class="string">`json:&quot;maxbackups&quot; yaml:&quot;maxbackups&quot;`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LocalTime determines if the time used for formatting the timestamps in</span></span><br><span class="line"><span class="comment">// backup files is the computer&#x27;s local time.  The default is to use UTC</span></span><br><span class="line"><span class="comment">// time.</span></span><br><span class="line">LocalTime <span class="type">bool</span> <span class="string">`json:&quot;localtime&quot; yaml:&quot;localtime&quot;`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Compress determines if the rotated log files should be compressed</span></span><br><span class="line"><span class="comment">// using gzip. The default is not to perform compression.</span></span><br><span class="line">Compress <span class="type">bool</span> <span class="string">`json:&quot;compress&quot; yaml:&quot;compress&quot;`</span></span><br><span class="line"></span><br><span class="line">size <span class="type">int64</span></span><br><span class="line">file *os.File</span><br><span class="line">mu   sync.Mutex</span><br><span class="line"></span><br><span class="line">millCh    <span class="keyword">chan</span> <span class="type">bool</span></span><br><span class="line">startMill sync.Once</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可导出的变量：</p><ul><li>Filename：输出日志的文件名，这个文件名是一个全路径，即日志文件会在Filename指定的文件的目录下，进行存储和老化</li><li>MaxSize：日志文件的最大占用空间，也就是日志文件达到多大时触发日志文件的分割。单位是MB</li><li>MaxAge：已经被分割存储的日志文件最大的留存时间，单位是天</li><li>MaxBackups：已经被分割存储的日志文件最多的留存个数。MaxBackups 和上面的 MaxAge 会共同生效，满足二者中的一个条件就会触发日志文件的删除</li><li>LocalTime：被分割的日志文件上的时间戳是否要使用本地时区，默认会使用UTC时间</li><li>Compress：指定被分割之后的文件是否要压缩。使用 gzip 算法压缩</li></ul><p>内部变量：</p><ul><li>size：当前日志文件大小</li><li>file：当前日志文件</li><li>mu：Logger 的全局锁</li><li>millCh：用于唤醒 millRun，进行日志文件压缩删除的处理</li></ul><h2 id="主流程"><a href="#主流程" class="headerlink" title="主流程"></a>主流程</h2><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p><img src="/images/415317b0478397e5127dc32546ff75ac.png" alt="Untitled.png"></p><h3 id="Write"><a href="#Write" class="headerlink" title="Write"></a>Write</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Write implements io.Writer.  If a write would cause the log file to be larger</span></span><br><span class="line"><span class="comment">// than MaxSize, the file is closed, renamed to include a timestamp of the</span></span><br><span class="line"><span class="comment">// current time, and a new log file is created using the original log file name.</span></span><br><span class="line"><span class="comment">// If the length of the write is greater than MaxSize, an error is returned.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Logger)</span></span> Write(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">l.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> l.mu.Unlock()</span><br><span class="line"></span><br><span class="line">writeLen := <span class="type">int64</span>(<span class="built_in">len</span>(p))</span><br><span class="line"><span class="keyword">if</span> writeLen &gt; l.max() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, fmt.Errorf(</span><br><span class="line"><span class="string">&quot;write length %d exceeds maximum file size %d&quot;</span>, writeLen, l.max(),</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> l.file == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> err = l.openExistingOrNew(<span class="built_in">len</span>(p)); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> l.size+writeLen &gt; l.max() &#123;</span><br><span class="line"><span class="keyword">if</span> err := l.rotate(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">n, err = l.file.Write(p)</span><br><span class="line">l.size += <span class="type">int64</span>(n)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> n, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Write的逻辑很简单，先全局上锁保证并发安全，对入参做必要的校验，然后根据文件句柄的存在情况决定是否需要打开文件和创建文件、依据和日志文件写入后的大小判断是否要进行日志分割，最终调用写文件的方法，真正写入文件</p><p>下面分别看其中用到的 openExistingOrNew（负责获取到一个可写入的文件） 和 rotate（负责日志分割） 这两个关键方法</p><h3 id="openExistingOrNew"><a href="#openExistingOrNew" class="headerlink" title="openExistingOrNew"></a>openExistingOrNew</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// openExistingOrNew opens the logfile if it exists and if the current write</span></span><br><span class="line"><span class="comment">// would not put it over MaxSize.  If there is no such file or the write would</span></span><br><span class="line"><span class="comment">// put it over the MaxSize, a new file is created.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Logger)</span></span> openExistingOrNew(writeLen <span class="type">int</span>) <span class="type">error</span> &#123;</span><br><span class="line">l.mill()</span><br><span class="line"></span><br><span class="line">filename := l.filename()</span><br><span class="line">info, err := osStat(filename)</span><br><span class="line"><span class="keyword">if</span> os.IsNotExist(err) &#123;</span><br><span class="line"><span class="keyword">return</span> l.openNew()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;error getting log file info: %s&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> info.Size()+<span class="type">int64</span>(writeLen) &gt;= l.max() &#123;</span><br><span class="line"><span class="keyword">return</span> l.rotate()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">file, err := os.OpenFile(filename, os.O_APPEND|os.O_WRONLY, <span class="number">0644</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// if we fail to open the old log file for some reason, just ignore</span></span><br><span class="line"><span class="comment">// it and open a new log file.</span></span><br><span class="line"><span class="keyword">return</span> l.openNew()</span><br><span class="line">&#125;</span><br><span class="line">l.file = file</span><br><span class="line">l.size = info.Size()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果满足三个条件中的任何一个，就会创建新文件返回</p><ul><li>文件不存在</li><li>文件大小加上本次要写入内容后会超过限制</li><li>文件打开失败</li></ul><p>基本保证一定会获取到一个能写入日志信息的文件</p><p>这里调用了两个特别的方法 mill 和 openNew，先看 mill 这个比较重要的方法</p><h3 id="mill-millRun"><a href="#mill-millRun" class="headerlink" title="mill &amp; millRun"></a>mill &amp; millRun</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mill performs post-rotation compression and removal of stale log files,</span></span><br><span class="line"><span class="comment">// starting the mill goroutine if necessary.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Logger)</span></span> mill() &#123;</span><br><span class="line">l.startMill.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">l.millCh = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> l.millRun()</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> l.millCh &lt;- <span class="literal">true</span>:</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// millRun runs in a goroutine to manage post-rotation compression and removal</span></span><br><span class="line"><span class="comment">// of old log files.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Logger)</span></span> millRun() &#123;</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">range</span> l.millCh &#123;</span><br><span class="line"><span class="comment">// what am I going to do, log this?</span></span><br><span class="line">_ = l.millRunOnce()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>sync.Once 懒加载，启动清理日志文件的协程</li><li>通过向 channel 传递信息触发日志文件的清理操作</li></ul><p>这里写入 channel 的部分也挺有技巧的，搭配 select + default 来实现并发情况下丢弃后续的写入信息。因为一段时间内 mill 触发多次没有意义，所以做了这样一个处理</p><p>接着看 openNew 方法</p><h3 id="openNew"><a href="#openNew" class="headerlink" title="openNew"></a>openNew</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// openNew opens a new log file for writing, moving any old log file out of the</span></span><br><span class="line"><span class="comment">// way.  This methods assumes the file has already been closed.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Logger)</span></span> openNew() <span class="type">error</span> &#123;</span><br><span class="line">err := os.MkdirAll(l.dir(), <span class="number">0755</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;can&#x27;t make directories for new logfile: %s&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">name := l.filename()</span><br><span class="line">mode := os.FileMode(<span class="number">0600</span>)</span><br><span class="line">info, err := osStat(name)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// Copy the mode off the old logfile.</span></span><br><span class="line">mode = info.Mode()</span><br><span class="line"><span class="comment">// move the existing file</span></span><br><span class="line">newname := backupName(name, l.LocalTime)</span><br><span class="line"><span class="keyword">if</span> err := os.Rename(name, newname); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;can&#x27;t rename log file: %s&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// this is a no-op anywhere but linux</span></span><br><span class="line"><span class="keyword">if</span> err := chown(name, info); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// we use truncate here because this should only get called when we&#x27;ve moved</span></span><br><span class="line"><span class="comment">// the file ourselves. if someone else creates the file in the meantime,</span></span><br><span class="line"><span class="comment">// just wipe out the contents.</span></span><br><span class="line">f, err := os.OpenFile(name, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, mode)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;can&#x27;t open new logfile: %s&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">l.file = f</span><br><span class="line">l.size = <span class="number">0</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>文件路径中不存在的文件夹也会顺路全部创建</li><li>如果文件已经存在，则会先对原文件进行归档操作</li><li>创建新文件</li></ol><h3 id="millRunOnce"><a href="#millRunOnce" class="headerlink" title="millRunOnce"></a>millRunOnce</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// millRunOnce performs compression and removal of stale log files.</span></span><br><span class="line"><span class="comment">// Log files are compressed if enabled via configuration and old log</span></span><br><span class="line"><span class="comment">// files are removed, keeping at most l.MaxBackups files, as long as</span></span><br><span class="line"><span class="comment">// none of them are older than MaxAge.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Logger)</span></span> millRunOnce() <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">if</span> l.MaxBackups == <span class="number">0</span> &amp;&amp; l.MaxAge == <span class="number">0</span> &amp;&amp; !l.Compress &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">files, err := l.oldLogFiles()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 基于旧日志文件信息</span></span><br><span class="line"><span class="comment">// 依据配置内容判断对应文件是否需要进行删除、压缩操作</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>millRunOnce 就是真正执行日志的删除和压缩这些清理操作的地方，主要都是些业务内容了</p><p>值得一提的是 oldLogFiles 是通过遍历存储日志的文件夹，匹配文件名来判断一个文件是否属于它来进行管理的，所以可能对应文件夹下文件的命名需要稍微注意</p><p>oldLogFiles 中也依据时间对文件进行了排序，所以优先被清理的是旧文件</p><h3 id="rotate"><a href="#rotate" class="headerlink" title="rotate"></a>rotate</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rotate closes the current file, moves it aside with a timestamp in the name,</span></span><br><span class="line"><span class="comment">// (if it exists), opens a new file with the original filename, and then runs</span></span><br><span class="line"><span class="comment">// post-rotation processing and removal.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Logger)</span></span> rotate() <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := l.<span class="built_in">close</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := l.openNew(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">l.mill()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后回头看负责日志分割的 rotate 方法旧比较清晰了，因为用到的 openNew 和 mill 之前已经遇到过了</p><ol><li>关闭旧文件</li><li>创建新文件</li><li>触发文件清理</li></ol><h2 id="其他内容"><a href="#其他内容" class="headerlink" title="其他内容"></a>其他内容</h2><ul><li>可以直接使用 Logger.Rotate 方法来直接强制触发一次日志分割操作，可以凭借这个方法实现一些自定义的日志切割规则</li><li>millCh 肉眼可见的可以优化成 <code>chan struct&#123;&#125;</code> ，节省一点内存空间，这也是使用 channel 做信息通知时的常用伎俩</li><li>代码整体不复杂，方法的职责划分做的很好，做到了原子方法，拆分的很细致</li></ul><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul><li>判断是否属于日志文件的方法是匹配文件名，所以日志文件如果重命名就可能导致 lumberjack 不识别和管理</li><li>“ Lumberjack 假设只有一个进程正在写入输出文件。在同一台计算机上的多个进程中使用相同的伐木工人配置将导致不正确的行为。” 根本原因还是在于使用文件名匹配的方式管理日志文件，多进程操作时可能会因为并行执行而引发问题</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>项目地址：<a href="https://github.com/natefinch/lumberjack">natefinch&#x2F;lumberjack: lumberjack is a log rolling package for Go (github.com)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 源码学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ants: 协程池源码学习</title>
      <link href="//ants/"/>
      <url>//ants/</url>
      
        <content type="html"><![CDATA[<h1 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h1><p><code>ants</code>是一个高性能的 goroutine 池，实现了对大规模 goroutine 的调度管理、goroutine 复用，允许使用者在开发并发程序的时候限制 goroutine 数量，复用资源，达到更高效执行任务的效果。</p><h1 id="解决了什么问题"><a href="#解决了什么问题" class="headerlink" title="解决了什么问题"></a>解决了什么问题</h1><ul><li>提升性能：主要面向一类场景，大批量轻量级并发任务，任务执行成本与协程创建&#x2F;销毁成本量级接近</li><li>并发资源控制：研发能够明确系统全局并发度以及各个模块的并发度上限</li><li>协程生命周期控制：实时查看当前全局并发的协程数量；有一个统一的紧急入口释放全局协程</li></ul><p>带来的价值：</p><ol><li>限制并发的 goroutine 数量</li><li>复用 goroutine，减轻 runtime 调度压力，提升程序性能</li><li>规避过多的 goroutine 侵占系统资源（CPU&amp;内存）</li></ol><h1 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h1><p>创建 goroutine 池</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pool, _ := ants.NewPool(<span class="number">100</span>)</span><br></pre></td></tr></table></figure><p>提交任务</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ants.Submit(<span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>动态调整容量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pool.Tune(<span class="number">1000</span>) <span class="comment">// Tune its capacity to 1000</span></span><br><span class="line">pool.Tune(<span class="number">100000</span>) <span class="comment">// Tune its capacity to 100000</span></span><br></pre></td></tr></table></figure><p>释放资源</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pool.Release()</span><br></pre></td></tr></table></figure><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="核心结构"><a href="#核心结构" class="headerlink" title="核心结构"></a>核心结构</h2><p>架构图中包含了所有核心结构，并展现了分层关系，开发中最为常用的还是 Pool，主要沿着 Pool 这条线进行研究，PoolWithFunc 实现逻辑其实和 Pool 大差不差</p><p><img src="/images/355436df9ba90da6c1684082e2ea8815.png" alt="Untitled.png"></p><h3 id="pool"><a href="#pool" class="headerlink" title="pool"></a>pool</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pool accepts the tasks and process them concurrently,</span></span><br><span class="line"><span class="comment">// it limits the total of goroutines to a given number by recycling goroutines.</span></span><br><span class="line"><span class="keyword">type</span> Pool <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// capacity of the pool, a negative value means that the capacity of pool is limitless, an infinite pool is used to</span></span><br><span class="line"><span class="comment">// avoid potential issue of endless blocking caused by nested usage of a pool: submitting a task to pool</span></span><br><span class="line"><span class="comment">// which submits a new task to the same pool.</span></span><br><span class="line">capacity <span class="type">int32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// running is the number of the currently running goroutines.</span></span><br><span class="line">running <span class="type">int32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// lock for protecting the worker queue.</span></span><br><span class="line">lock sync.Locker</span><br><span class="line"></span><br><span class="line"><span class="comment">// workers is a slice that store the available workers.</span></span><br><span class="line">workers workerQueue</span><br><span class="line"></span><br><span class="line"><span class="comment">// state is used to notice the pool to closed itself.</span></span><br><span class="line">state <span class="type">int32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// cond for waiting to get an idle worker.</span></span><br><span class="line">cond *sync.Cond</span><br><span class="line"></span><br><span class="line"><span class="comment">// workerCache speeds up the obtainment of a usable worker in function:retrieveWorker.</span></span><br><span class="line">workerCache sync.Pool</span><br><span class="line"></span><br><span class="line"><span class="comment">// waiting is the number of goroutines already been blocked on pool.Submit(), protected by pool.lock</span></span><br><span class="line">waiting <span class="type">int32</span></span><br><span class="line"></span><br><span class="line">purgeDone <span class="type">int32</span></span><br><span class="line">stopPurge context.CancelFunc</span><br><span class="line"></span><br><span class="line">ticktockDone <span class="type">int32</span></span><br><span class="line">stopTicktock context.CancelFunc</span><br><span class="line"></span><br><span class="line">now atomic.Value</span><br><span class="line"></span><br><span class="line">options *Options</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Pool 就是所谓的协程池，管理 goroutine，限制 goroutine 数目</p><ul><li>capacity：协程池容量，最大 goroutine 数量限制</li><li>running：正在运行的协程数目</li><li>lock：自制的轻量自旋锁，用于保护 goWorker 队列</li><li>workers：goWorker 队列，真正意义上的协程池，存放着可以复用的 goroutine 资源</li><li>state：协程池状态标识，0-打开；1-关闭</li><li>cond：go中的信号量，是一种 goroutine 同步工具。如果 pool 配置 blocking 模式，则会用于协调 goroutine 的唤醒和挂起</li><li>workerCache：goWorker 对象池，缓存着被释放的 goWorker，用于 goWorker 的资源复用</li><li>waiting：被阻塞的协程数目</li><li>purgeDone：标识释放 goWorker 的协程是否关闭</li><li>stopPurge：用于关闭释放 goWorker 的协程</li><li>ticktockDone：标识时间更新协程是否关闭</li><li>stopTicktock：用于关闭时间更新协程的函数</li><li>now：缓存当前时间，在 goWorker 执行完任务放回 goWorker 队列时需要记录任务完成时间，通过缓存+异步更新的方式，减少 time.Now() 的调用次数</li><li>optons：一些定制化配置</li></ul><h3 id="workerQueue"><a href="#workerQueue" class="headerlink" title="workerQueue"></a>workerQueue</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> workerQueue <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="built_in">len</span>() <span class="type">int</span></span><br><span class="line">isEmpty() <span class="type">bool</span></span><br><span class="line">insert(worker) <span class="type">error</span></span><br><span class="line">detach() worker</span><br><span class="line">refresh(duration time.Duration) []worker <span class="comment">// clean up the stale workers and return them</span></span><br><span class="line">reset()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>workerQueue 是一个接口，定义了数据操作所需的 api</p><p>接口的实现有 <code>workerStack</code> 和 <code>loopQueue</code> ，从命名即可看出一个是栈结构一个是循环队列的结构</p><p>如果 <code>Pool</code>使用了 PreAlloc 容量预分配配置，会选用 <code>loopQueue</code> 实现，否则会默认选用<code>workerStack</code> 的实现</p><p>这里所谓的是否预分配其实指的是他们内部实现中存放 <code>goWorker</code>结构的 slice 容量是否预分配</p><p><code>loopQueue</code> 的容量在创建后就不能够更改了，而<code>workerStack</code> 可以通过 Tune() 方法动态更新容量</p><p>继续关注一下 <code>workerStack</code> 的实现</p><h3 id="workerStack"><a href="#workerStack" class="headerlink" title="workerStack"></a>workerStack</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> workerStack <span class="keyword">struct</span> &#123;</span><br><span class="line">items  []worker</span><br><span class="line">expiry []worker</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>items：协程池中可用的 goWorker</li><li>expiry：已过期需要清理释放的 goWorker</li></ul><h3 id="goWorker"><a href="#goWorker" class="headerlink" title="goWorker"></a>goWorker</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// goWorker is the actual executor who runs the tasks,</span></span><br><span class="line"><span class="comment">// it starts a goroutine that accepts tasks and</span></span><br><span class="line"><span class="comment">// performs function calls.</span></span><br><span class="line"><span class="keyword">type</span> goWorker <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// pool who owns this worker.</span></span><br><span class="line">pool *Pool</span><br><span class="line"></span><br><span class="line"><span class="comment">// task is a job should be done.</span></span><br><span class="line">task <span class="keyword">chan</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// lastUsed will be updated when putting a worker back into queue.</span></span><br><span class="line">lastUsed time.Time</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>goWorker 是任务真正的执行者，可以认为它代表了协程池中的协程资源</p><ul><li>pool：goWorker 所属的协程池</li><li>task：goWorker 用于接收异步任务的管道</li><li>lastUsed：goWorker 回收到协程池的时间（上一次结束任务运行的时间）</li></ul><h2 id="主流程"><a href="#主流程" class="headerlink" title="主流程"></a>主流程</h2><p><img src="/images/aaa1b050dd6116ece7c74917d3e4f570.png" alt="Untitled.png"></p><h3 id="NewPool-创建协程池"><a href="#NewPool-创建协程池" class="headerlink" title="NewPool 创建协程池"></a>NewPool 创建协程池</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewPool instantiates a Pool with customized options.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPool</span><span class="params">(size <span class="type">int</span>, options ...Option)</span></span> (*Pool, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="comment">// 校验用户入参，设置 options</span></span><br><span class="line"><span class="keyword">if</span> size &lt;= <span class="number">0</span> &#123;</span><br><span class="line">size = <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">opts := loadOptions(options...)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !opts.DisablePurge &#123;</span><br><span class="line"><span class="keyword">if</span> expiry := opts.ExpiryDuration; expiry &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, ErrInvalidPoolExpiry</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> expiry == <span class="number">0</span> &#123;</span><br><span class="line">opts.ExpiryDuration = DefaultCleanIntervalTime</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> opts.Logger == <span class="literal">nil</span> &#123;</span><br><span class="line">opts.Logger = defaultLogger</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造 Pool 数据结构</span></span><br><span class="line">p := &amp;Pool&#123;</span><br><span class="line">capacity: <span class="type">int32</span>(size),</span><br><span class="line">lock:     syncx.NewSpinLock(),</span><br><span class="line">options:  opts,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 构造 goWorker 对象池</span></span><br><span class="line">p.workerCache.New = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;goWorker&#123;</span><br><span class="line">pool: p,</span><br><span class="line">task: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>, workerChanCap),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 构造 goWorker 队列，依据是否预分配注入不同的实现结构</span></span><br><span class="line"><span class="keyword">if</span> p.options.PreAlloc &#123;</span><br><span class="line"><span class="keyword">if</span> size == <span class="number">-1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, ErrInvalidPreAllocSize</span><br><span class="line">&#125;</span><br><span class="line">p.workers = newWorkerQueue(queueTypeLoopQueue, size)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">p.workers = newWorkerQueue(queueTypeStack, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造用于并发控制的 sync.Cond</span></span><br><span class="line">p.cond = sync.NewCond(p.lock)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动负责释放 goWorker 协程</span></span><br><span class="line">p.goPurge()</span><br><span class="line"><span class="comment">// 启动负责更新 now 的协程</span></span><br><span class="line">p.goTicktock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> p, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NewPool 方法用于创建一个新的协程池</p><ol><li>校验用户入参，设置 options</li><li>构造 Pool 数据结构</li><li>构造 goWorker 对象池</li><li>构造 goWorker 队列，依据是否预分配注入不同的实现结构</li><li>构造用于并发控制的 sync.Cond</li><li>启动负责释放 goWorker 协程</li><li>启动负责更新 now 的协程</li></ol><h3 id="Pool-Submit-提交任务"><a href="#Pool-Submit-提交任务" class="headerlink" title="Pool.Submit 提交任务"></a>Pool.Submit 提交任务</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Submit submits a task to this pool.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Note that you are allowed to call Pool.Submit() from the current Pool.Submit(),</span></span><br><span class="line"><span class="comment">// but what calls for special attention is that you will get blocked with the last</span></span><br><span class="line"><span class="comment">// Pool.Submit() call once the current Pool runs out of its capacity, and to avoid this,</span></span><br><span class="line"><span class="comment">// you should instantiate a Pool with ants.WithNonblocking(true).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span></span> Submit(task <span class="function"><span class="keyword">func</span><span class="params">()</span></span>) <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">if</span> p.IsClosed() &#123;</span><br><span class="line"><span class="keyword">return</span> ErrPoolClosed</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">w, err := p.retrieveWorker()</span><br><span class="line"><span class="keyword">if</span> w != <span class="literal">nil</span> &#123;</span><br><span class="line">w.inputFunc(task)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Pool.Submit 方法的作用是将任务提交给协程池执行</p><ol><li>检查协程池是否已经关闭，如果关闭则直接返回 err</li><li>调用 retrieveWorker 从协程池中获取一个可供使用的 goWorker</li><li>通过 channel 将任务发送给 goWorker 执行</li></ol><h3 id="Pool-retrieveWorker-获取可用的goWorker"><a href="#Pool-retrieveWorker-获取可用的goWorker" class="headerlink" title="Pool.retrieveWorker 获取可用的goWorker"></a>Pool.retrieveWorker 获取可用的goWorker</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// retrieveWorker returns an available worker to run the tasks.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span></span> retrieveWorker() (w worker, err <span class="type">error</span>) &#123;</span><br><span class="line">p.lock.Lock()</span><br><span class="line"></span><br><span class="line">retry:</span><br><span class="line"><span class="comment">// First try to fetch the worker from the queue.</span></span><br><span class="line"><span class="keyword">if</span> w = p.workers.detach(); w != <span class="literal">nil</span> &#123;</span><br><span class="line">p.lock.Unlock()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If the worker queue is empty, and we don&#x27;t run out of the pool capacity,</span></span><br><span class="line"><span class="comment">// then just spawn a new worker goroutine.</span></span><br><span class="line"><span class="keyword">if</span> capacity := p.Cap(); capacity == <span class="number">-1</span> || capacity &gt; p.Running() &#123;</span><br><span class="line">p.lock.Unlock()</span><br><span class="line">w = p.workerCache.Get().(*goWorker)</span><br><span class="line">w.run()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bail out early if it&#x27;s in nonblocking mode or the number of pending callers reaches the maximum limit value.</span></span><br><span class="line"><span class="keyword">if</span> p.options.Nonblocking || (p.options.MaxBlockingTasks != <span class="number">0</span> &amp;&amp; p.Waiting() &gt;= p.options.MaxBlockingTasks) &#123;</span><br><span class="line">p.lock.Unlock()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, ErrPoolOverload</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Otherwise, we&#x27;ll have to keep them blocked and wait for at least one worker to be put back into pool.</span></span><br><span class="line">p.addWaiting(<span class="number">1</span>)</span><br><span class="line">p.cond.Wait() <span class="comment">// block and wait for an available worker</span></span><br><span class="line">p.addWaiting(<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> p.IsClosed() &#123;</span><br><span class="line">p.lock.Unlock()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, ErrPoolClosed</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">goto</span> retry</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Pool.retrieveWorker 将获取一个空闲的 goWorker 用于任务的执行</p><ol><li>要操作 workerQueue，所以需要上锁保护</li><li>调用 workerQueue.detach() 尝试从 workerQueue 中取出一个 goWorker 返回</li><li>检查当前正在使用的 goWorker 是否到达协程池的容量，如果容量未超出限额，则通过 workerCache 对象池获取并启动一个 goWorker 返回</li><li>如果容量超出限额，且 Pool 为非阻塞模式，则返回 err</li><li>如果容量超出限额，且 Pool 为阻塞模式但等待执行的任务数目到达配置的上限，返回 err</li><li>如果容量超出限额，且 Pool 为阻塞模式但等待执行的任务数目未达上线，则通过 cond 挂起</li></ol><h3 id="workerQueue-detach-取出一个-goWorker"><a href="#workerQueue-detach-取出一个-goWorker" class="headerlink" title="workerQueue.detach 取出一个 goWorker"></a>workerQueue.detach 取出一个 goWorker</h3><p>这里就关注一下 <code>workerStack</code> 的实现，<code>loopQueue</code> 也是类似的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wq *workerStack)</span></span> detach() worker &#123;</span><br><span class="line">l := wq.<span class="built_in">len</span>()</span><br><span class="line"><span class="keyword">if</span> l == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">w := wq.items[l<span class="number">-1</span>]</span><br><span class="line">wq.items[l<span class="number">-1</span>] = <span class="literal">nil</span> <span class="comment">// avoid memory leaks</span></span><br><span class="line">wq.items = wq.items[:l<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> w</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>workerQueue.detach 做的工作其实就是从 slice 中取出最后一个元素，比较简单</p><p>值得注意的点是 <code>wq.items[l-1] = nil</code> 这步防止内存泄漏的操作</p><p>详细可参考 <a href="https://github.com/panjf2000/ants/pull/107">issue: Avoid memory leak #107</a></p><h3 id="goWorker-run-执行任务"><a href="#goWorker-run-执行任务" class="headerlink" title="goWorker.run 执行任务"></a>goWorker.run 执行任务</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// run starts a goroutine to repeat the process</span></span><br><span class="line"><span class="comment">// that performs the function calls.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *goWorker)</span></span> run() &#123;</span><br><span class="line">w.pool.addRunning(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">w.pool.addRunning(<span class="number">-1</span>)</span><br><span class="line">w.pool.workerCache.Put(w)</span><br><span class="line"><span class="keyword">if</span> p := <span class="built_in">recover</span>(); p != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> ph := w.pool.options.PanicHandler; ph != <span class="literal">nil</span> &#123;</span><br><span class="line">ph(p)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">w.pool.options.Logger.Printf(<span class="string">&quot;worker exits from panic: %v\n%s\n&quot;</span>, p, debug.Stack())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Call Signal() here in case there are goroutines waiting for available workers.</span></span><br><span class="line">w.pool.cond.Signal()</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> f := <span class="keyword">range</span> w.task &#123;</span><br><span class="line"><span class="keyword">if</span> f == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">f()</span><br><span class="line"><span class="keyword">if</span> ok := w.pool.revertWorker(w); !ok &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>阶段一：goWorker 的运行</p><ul><li>不断从 task channel 中获取任务并执行，任务执行完毕后通过 revertWorker 将 goWorker 结构放回 workerQueue，goroutine 并没有退出而是阻塞等待新任务</li><li>这里就是对于 goroutine 的复用，也是 ants 高性能的关键</li></ul><p>阶段二：goWorker 的释放</p><ul><li>当前 goWorker 在负责释放 goWorker 协程中被调用 finish 方法，finish 触发 goWorker 销毁的方法是往 task 中注入空值，从 task 中取得 nil，由此进入释放流程</li><li>goWorker 在执行过程中出现 panic，或是回归 workerQueue 失败（例如 Pool 已关闭），也会被 defer 兜底，并进入释放流程</li><li>将 goWorker 放入 WorkerCache 对象池</li><li>通过 cond.Signal() 唤醒一个阻塞等待的协程获取 goWorker 启动任务</li></ul><h3 id="Pool-revertWorker-回收goWorker"><a href="#Pool-revertWorker-回收goWorker" class="headerlink" title="Pool.revertWorker 回收goWorker"></a>Pool.revertWorker 回收goWorker</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// revertWorker puts a worker back into free pool, recycling the goroutines.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span></span> revertWorker(worker *goWorker) <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">if</span> capacity := p.Cap(); (capacity &gt; <span class="number">0</span> &amp;&amp; p.Running() &gt; capacity) || p.IsClosed() &#123;</span><br><span class="line">p.cond.Broadcast()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">worker.lastUsed = p.nowTime()</span><br><span class="line"></span><br><span class="line">p.lock.Lock()</span><br><span class="line"><span class="comment">// To avoid memory leaks, add a double check in the lock scope.</span></span><br><span class="line"><span class="comment">// Issue: https://github.com/panjf2000/ants/issues/113</span></span><br><span class="line"><span class="keyword">if</span> p.IsClosed() &#123;</span><br><span class="line">p.lock.Unlock()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := p.workers.insert(worker); err != <span class="literal">nil</span> &#123;</span><br><span class="line">p.lock.Unlock()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Notify the invoker stuck in &#x27;retrieveWorker()&#x27; of there is an available worker in the worker queue.</span></span><br><span class="line">p.cond.Signal()</span><br><span class="line">p.lock.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Pool.revertWorker 负责将 goWorker 放回到 workerQueue 中</p><ul><li>更新 goWorker 记录的时间 lastUsed，lastUsed 是用于判断闲置的 goWorker 是否应该被回收的依据</li><li>将 goWorker 放回 workerQueue 中</li><li>唤醒一个等待的协程取用 goWorker</li></ul><h3 id="Pool-goPurge-释放goWorker"><a href="#Pool-goPurge-释放goWorker" class="headerlink" title="Pool.goPurge 释放goWorker"></a>Pool.goPurge 释放goWorker</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span></span> goPurge() &#123;</span><br><span class="line"><span class="keyword">if</span> p.options.DisablePurge &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Start a goroutine to clean up expired workers periodically.</span></span><br><span class="line"><span class="keyword">var</span> ctx context.Context</span><br><span class="line">ctx, p.stopPurge = context.WithCancel(context.Background())</span><br><span class="line"><span class="keyword">go</span> p.purgeStaleWorkers(ctx)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回头看在 Pool.New 中使用 Pool.goPurge 启动的用于释放 goWorker 的协程</p><ul><li>通过 context.Context 来控制协程的退出</li><li>使用 Pool.purgeStaleWorkers 启动真正的 goWorker 释放协程</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// purgeStaleWorkers clears stale workers periodically, it runs in an individual goroutine, as a scavenger.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span></span> purgeStaleWorkers(ctx context.Context) &#123;</span><br><span class="line">ticker := time.NewTicker(p.options.ExpiryDuration)</span><br><span class="line"></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">ticker.Stop()</span><br><span class="line">atomic.StoreInt32(&amp;p.purgeDone, <span class="number">1</span>)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> &lt;-ticker.C:</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> p.IsClosed() &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> isDormant <span class="type">bool</span></span><br><span class="line">p.lock.Lock()</span><br><span class="line">staleWorkers := p.workers.refresh(p.options.ExpiryDuration)</span><br><span class="line">n := p.Running()</span><br><span class="line">isDormant = n == <span class="number">0</span> || n == <span class="built_in">len</span>(staleWorkers)</span><br><span class="line">p.lock.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Notify obsolete workers to stop.</span></span><br><span class="line"><span class="comment">// This notification must be outside the p.lock, since w.task</span></span><br><span class="line"><span class="comment">// may be blocking and may consume a lot of time if many workers</span></span><br><span class="line"><span class="comment">// are located on non-local CPUs.</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> staleWorkers &#123;</span><br><span class="line">staleWorkers[i].finish()</span><br><span class="line">staleWorkers[i] = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// There might be a situation where all workers have been cleaned up (no worker is running),</span></span><br><span class="line"><span class="comment">// while some invokers still are stuck in p.cond.Wait(), then we need to awake those invokers.</span></span><br><span class="line"><span class="keyword">if</span> isDormant &amp;&amp; p.Waiting() &gt; <span class="number">0</span> &#123;</span><br><span class="line">p.cond.Broadcast()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Pool.purgeStaleWorkers 负责 goWorker 的释放工作</p><ul><li>定时检查 workerQueue 中的 goWorker 是否闲置过长时间，对过期的 goWorker 进行销毁释放</li><li>对于 goWorker 过期的判断是基于 goWorker.lastUsed 来做的，workerStack 和 loopQueue 这两种 workerQueue 实现中都是通过二分查找的方式来获取过期 goWorker</li></ul><h3 id="Pool-Release-释放协程池"><a href="#Pool-Release-释放协程池" class="headerlink" title="Pool.Release 释放协程池"></a>Pool.Release 释放协程池</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Release closes this pool and releases the worker queue.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span></span> Release() &#123;</span><br><span class="line"><span class="keyword">if</span> !atomic.CompareAndSwapInt32(&amp;p.state, OPENED, CLOSED) &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> p.stopPurge != <span class="literal">nil</span> &#123;</span><br><span class="line">p.stopPurge()</span><br><span class="line">p.stopPurge = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">p.stopTicktock()</span><br><span class="line">p.stopTicktock = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">p.lock.Lock()</span><br><span class="line">p.workers.reset()</span><br><span class="line">p.lock.Unlock()</span><br><span class="line"><span class="comment">// There might be some callers waiting in retrieveWorker(), so we need to wake them up to prevent</span></span><br><span class="line"><span class="comment">// those callers blocking infinitely.</span></span><br><span class="line">p.cond.Broadcast()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Pool.Release 在协程池不再使用时，用于销毁，释放系统资源</p><ol><li>通过 atomic 包的原子操作，无锁更新 Pool 的状态，标记为关闭</li><li>通过 context 关闭辅助协程</li><li>释放 workerQueue 的资源</li><li>为了防止有 goroutine 还阻塞在<code>p.cond.Wait()</code>上，执行一次<code>p.cond.Broadcast()</code></li></ol><h2 id="其他内容"><a href="#其他内容" class="headerlink" title="其他内容"></a>其他内容</h2><h3 id="PoolWithFunc"><a href="#PoolWithFunc" class="headerlink" title="PoolWithFunc"></a>PoolWithFunc</h3><p>和 Pool 的设计整体上都大差不差</p><p>只是 Pool 使用 goWorker 来代表 goroutine 资源，需要传入 func 作为任务执行；而PoolWithFunc 使用 goWorkerWithFunc 来代表 goroutine 资源，所需执行的任务函数在协程池创建时就已经指定，提交任务是需要传入的内容就不是是函数了，而是函数运行的参数</p><h3 id="MultiPool"><a href="#MultiPool" class="headerlink" title="MultiPool"></a>MultiPool</h3><p>MultiPool 内容会初始化多个协程池，可以根据预先定义的负载均衡策略：轮询或者最少使用策略，从多个协程池中获取 goWorker</p><p>Pool 中有保护 workerQueue 的自旋锁，之所以新加了这个，是为了降低锁的颗粒度，以此提高性能</p><h3 id="MultiPoolWithFunc"><a href="#MultiPoolWithFunc" class="headerlink" title="MultiPoolWithFunc"></a>MultiPoolWithFunc</h3><p>与 MultiPool 之间的关系就和 Pool 和 PoolWithFunc 之间的关系差不多</p><h3 id="spinLock-自制的轻量级自旋锁"><a href="#spinLock-自制的轻量级自旋锁" class="headerlink" title="spinLock 自制的轻量级自旋锁"></a>spinLock 自制的轻量级自旋锁</h3><p>嫌弃 sync.Mutex 太重了，利用 atomic.CompareAndSwapUint32() 这个原子操作实现了一个自旋锁。</p><p>与其他类型的锁不同，自旋锁在加锁失败之后不会立刻进入等待，而是会继续尝试。这对于很快就能获得锁的应用来说能极大提升性能，因为能减少加锁和解锁导致的线程切换</p><p>加锁操作中使用了指数退避的算法，连续的抢锁失败会让惩罚增加，runtime.Gosched() 会让当前 goroutine 让出 cpu，减少空转</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> spinLock <span class="type">uint32</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> maxBackoff = <span class="number">16</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sl *spinLock)</span></span> Lock() &#123;</span><br><span class="line">backoff := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> !atomic.CompareAndSwapUint32((*<span class="type">uint32</span>)(sl), <span class="number">0</span>, <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">// Leverage the exponential backoff algorithm, see https://en.wikipedia.org/wiki/Exponential_backoff.</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; backoff; i++ &#123;</span><br><span class="line">runtime.Gosched()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> backoff &lt; maxBackoff &#123;</span><br><span class="line">backoff &lt;&lt;= <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sl *spinLock)</span></span> Unlock() &#123;</span><br><span class="line">atomic.StoreUint32((*<span class="type">uint32</span>)(sl), <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><blockquote><p>💡 使用 ants 的一个理由是通过池子来自动管理 goroutine 的生命周期，不用手动管理</p></blockquote><blockquote><p>💡 考虑一下提交给协程池的任务中又启动了新协程的情景，读了源码自然能够知道，在这种情况下，这些协程是不受 ants 限制的，还是需要手动管理生命周期。所以避免在提交的任务中启动新协程，或是设计好这些新协程的生命周期管理</p></blockquote><blockquote><p>💡 ants 擅长处理的任务应当是耗时短但是量大的小任务。对于耗时长和量小的任务而言，体现不出 ants 对于 goroutine 复用的性能提升</p></blockquote><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>项目地址：<a href="https://github.com/panjf2000/ants">panjf2000&#x2F;ants: 🐜🐜🐜 ants is a high-performance and low-cost goroutine pool in Go. (github.com)</a></li><li><a href="https://taohuawu.club/archives/high-performance-implementation-of-goroutine-pool">GMP 并发调度器深度解析之手撸一个高性能 goroutine pool - Strike Freedom (taohuawu.club)</a></li><li><a href="https://medium.com/coinmonks/visually-understanding-worker-pool-48a83b7fc1f5">Visually Understanding Worker Pool | by David | Coinmonks | Medium</a></li><li><a href="https://mp.weixin.qq.com/s/Uctu_uKHk5oY0EtSZGUvsA">Golang 协程池 Ants 实现原理 (qq.com)</a></li><li><a href="https://darjun.github.io/2021/06/04/godailylib/ants-src/">Go 每日一库之 ants（源码赏析） - 大俊的博客 (darjun.github.io)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 源码学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hugo + github pages: 零成本自建技术博客</title>
      <link href="//build-blog-hugo/"/>
      <url>//build-blog-hugo/</url>
      
        <content type="html"><![CDATA[<h3 id="方案选择"><a href="#方案选择" class="headerlink" title="方案选择"></a>方案选择</h3><p>github pages 提供博客站点 + hugo 提供博客模板 + github actions 自动构建和发布</p><h3 id="part-1-Github-Pages"><a href="#part-1-Github-Pages" class="headerlink" title="part 1 : Github Pages"></a>part 1 : Github Pages</h3><p>官网：<a href="https://pages.github.com/">GitHub Pages</a></p><p>选择 github pages 的优点就是 github 使用频率高，并且作为全球最大的代码托管平台，也很稳定，即使是免费提供使用也不用担心跑路的问题，缺点当然就是对于国内的网络访问不算友好</p><p>步骤如下：</p><ol><li>新建 Repositories 用于存储博客内容，注意：名称格式为：<code>&lt;用户名&gt;.github.io</code></li><li>将博客网页代码上传至仓库中</li><li>访问博客，博客站点访问地址为：**<code>https://&lt;</code><strong><code>用户名&gt;</code></strong><code>.github.io/</code>**</li></ol><h3 id="part-2-hugo"><a href="#part-2-hugo" class="headerlink" title="part 2 : hugo"></a>part 2 : hugo</h3><p>官网：<a href="https://gohugo.io/">The world’s fastest framework for building websites | Hugo (gohugo.io)</a></p><p>hugo 是使用 go 语言实现的静态博客网站生成器，可将 md 文章内容转换为美观的博客网站代码</p><p>步骤如下：</p><ol><li><p>安装 git 用于将博客网页上传 Github, 安装 hugo 用于生成博客网页（最好安装extended版本）</p></li><li><p>运行 <code>hugo new site &lt;文件夹名&gt;</code>，创建站点，创建结束后也会有后续使用流程的指示</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="title class_">Change</span> the current directory to <span class="attr">D</span>:\<span class="title class_">AAAData</span>\<span class="title class_">Code</span>\<span class="title class_">Blog</span>\blog.</span><br><span class="line"><span class="number">2.</span> <span class="title class_">Create</span> or install a <span class="attr">theme</span>:</span><br><span class="line">   - <span class="title class_">Create</span> a <span class="keyword">new</span> theme <span class="keyword">with</span> the command <span class="string">&quot;hugo new theme &lt;THEMENAME&gt;&quot;</span></span><br><span class="line">   - <span class="title class_">Install</span> a theme <span class="keyword">from</span> <span class="attr">https</span>:<span class="comment">//themes.gohugo.io/</span></span><br><span class="line"><span class="number">3.</span> <span class="title class_">Edit</span> hugo.<span class="property">toml</span>, setting the <span class="string">&quot;theme&quot;</span> property to the theme name.</span><br><span class="line"><span class="number">4.</span> <span class="title class_">Create</span> <span class="keyword">new</span> content <span class="keyword">with</span> the command <span class="string">&quot;hugo new content &lt;SECTIONNAME&gt;\&lt;FILENAME&gt;.&lt;FORMAT&gt;&quot;</span>.</span><br><span class="line"><span class="number">5.</span> <span class="title class_">Start</span> the embedded web server <span class="keyword">with</span> the command <span class="string">&quot;hugo server --buildDrafts&quot;</span>.</span><br></pre></td></tr></table></figure></li><li><p>安装主题，我选用的是 LoveIt，运行 <code>git clone https://github.com/dillonzq/LoveIt.git themes/LoveIt</code></p></li><li><p>依据主题配置说明，例如 LoveIt 主题的 <a href="https://hugoloveit.com/">https://hugoloveit.com/</a>，配置 hugo.toml</p></li><li><p>在 content 文件夹下编写 md 文章，直接新建 md 文件当然也是可以的，但是推荐运行 <code>hugo new content &lt;FILENAME&gt;</code> 来生成博客文章 md 文件，可以自动添加文章头部的默认元数据配置</p></li><li><p>运行 hugo 指令生成静态博客网站代码，生成结果位于 public 文件夹中</p></li><li><p>将 public 文件夹中的内容上传至 Github Pages 所对应的仓库</p></li></ol><h3 id="part-3-Github-Actions"><a href="#part-3-Github-Actions" class="headerlink" title="part 3 : Github Actions"></a>part 3 : Github Actions</h3><p>github actions 是 github 自带的 CICD 系统，可以直接搭配使用</p><p>目前我们的博客其实是可以正常使用了，但是每次修改完内容后都需要手动运行 hugo 命令生成静态网页文件，然后再手动将 public 文件夹下的内容上传至 github pages 所对应的仓库，较为繁琐，可以说用 github actions 来自动化这部分流程</p><p>我们最终需要两个 github 仓库，一个我们称之为 博客源仓库，这里存储博客的内容和 hugo 的配置等，另一个是 github pages 所对应的的仓库</p><p>最终的效果是：我们在本地的站点中写博客，然后推送至 博客源仓库，触发博客源仓库的 github actions，自动生成静态网页文件并推送至 github pages 仓库</p><p>步骤如下：</p><ol><li><p>添加 github actions 配置</p><p> 配置需要放置在仓库目录 <code>.github/workflows</code> 下，以 <code>.yml</code> 为后缀</p><p> 下面是一个例子，可以按需修改</p> <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">deploy</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">    <span class="attr">push:</span></span><br><span class="line">    <span class="attr">workflow_dispatch:</span></span><br><span class="line">    <span class="attr">schedule:</span></span><br><span class="line">        <span class="comment"># Runs everyday at 8:00 AM</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">cron:</span> <span class="string">&quot;0 0 * * *&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">    <span class="attr">build:</span></span><br><span class="line">        <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">        <span class="attr">steps:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span></span><br><span class="line">              <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">              <span class="attr">with:</span></span><br><span class="line">                  <span class="attr">submodules:</span> <span class="literal">true</span></span><br><span class="line">                  <span class="attr">fetch-depth:</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">Hugo</span></span><br><span class="line">              <span class="attr">uses:</span> <span class="string">peaceiris/actions-hugo@v2</span></span><br><span class="line">              <span class="attr">with:</span></span><br><span class="line">                  <span class="attr">hugo-version:</span> <span class="string">&quot;latest&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Build</span> <span class="string">Web</span></span><br><span class="line">              <span class="attr">run:</span> <span class="string">hugo</span></span><br><span class="line"></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">Web</span></span><br><span class="line">              <span class="attr">uses:</span> <span class="string">peaceiris/actions-gh-pages@v3</span></span><br><span class="line">              <span class="attr">with:</span></span><br><span class="line">                  <span class="attr">PERSONAL_TOKEN:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.PERSONAL_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">                  <span class="attr">EXTERNAL_REPOSITORY:</span> <span class="string">Aj002Th/Aj002Th.github.io</span></span><br><span class="line">                  <span class="attr">PUBLISH_BRANCH:</span> <span class="string">master</span></span><br><span class="line">                  <span class="attr">PUBLISH_DIR:</span> <span class="string">./public</span></span><br><span class="line">                  <span class="attr">commit_message:</span> <span class="string">$&#123;&#123;</span> <span class="string">github.event.head_commit.message</span> <span class="string">&#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>创建 Token，需要 workflows 和 repo 权限</p><p> 上述配置中使用到了一个变量 <code>secrets.PERSONAL_TOKEN</code> ，因为我们需要从博客仓库推送到外部 GitHub Pages 仓库，需要特定权限，要在 GitHub 账户下 <code>Setting - Developer setting - Personal access tokens</code> 下创建一个 Token，至少需要 workflows 和 repo 权限</p></li><li><p>配置 Token 到博客源仓库</p><p> 配置后复制生成的 Token（需要注意的是：Token 只会出现一次），然后在我们博客源仓库的 <code>Settings - Secrets and variables - Actions</code> 中添加 <code>PERSONAL_TOKEN</code> 环境变量为刚才的 Token，这样 GitHub Action 就可以获取到 Token 了</p></li><li><p>推送代码</p></li></ol><h3 id="最终成果"><a href="#最终成果" class="headerlink" title="最终成果"></a>最终成果</h3><ol><li>在本地的站点仓库中使用 md 编辑器写文章，并通过 hugo serve 命令预览生成的静态网页效果</li><li>完成文章内容后 git push 到 github 上的博客源仓库，同时触发 github actions 构建和生成最新的静态网页代码并发布到 github pages 所在仓库中</li><li>可以访问 github pages 查看最新博客内容</li></ol>]]></content>
      
      
      <categories>
          
          <category> 实践记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ssl 的中间人攻击原理</title>
      <link href="//ssl-man-in-the-middle-attack/"/>
      <url>//ssl-man-in-the-middle-attack/</url>
      
        <content type="html"><![CDATA[<p>中间人攻击就是有一个中间人服务器，他一边跟客户端建立连接，冒充服务端，另外一边跟服务端建立连接，冒充客户端，实现窃听、篡改等攻击</p><p>具体的实现方式主要有两种，分别是 <strong>ssl 嗅探</strong> 和 <strong>ssl 剥离</strong></p><h3 id="ssl-sniff（ssl-嗅探）"><a href="#ssl-sniff（ssl-嗅探）" class="headerlink" title="ssl sniff（ssl 嗅探）"></a>ssl sniff（ssl 嗅探）</h3><p><code>Attacker</code>在客户端发起连接时截获会话，用自己的公钥和公钥证书替换原本应该是由服务端提供的公钥和公钥证书。这样一来<code>Attacker</code>就可以用自己的私钥来解密客户端发送的请求，然后用来和服务端那边通信</p><p>问题：<code>Attacker</code>给客户端提供的证书毕竟不是真的证书，使用 https 单向认证，客户端去 ca 一检查就发现问题了，然后客户端可以自己选择是否继续连接，接受这个不受信任的证书。只要没有内鬼，遇到不受信任的就坚决不接受，就没有可乘之机。</p><h3 id="ssl-Strip（ssl-剥离）"><a href="#ssl-Strip（ssl-剥离）" class="headerlink" title="ssl Strip（ssl 剥离）"></a>ssl Strip（ssl 剥离）</h3><p>这种攻击更加复杂和麻烦，但是也更加高级和隐蔽、不需要伪造证书</p><p><code>Attacker</code>在客户端与服务器建立连接时，在<code>Attacker</code>与服务器之间形成HTTPS连接，而在客户端与<code>Attacker</code>之间形成<code>HTTP</code>连接，即将SSL层从原HTTPS连接中“剥离”。这样，既避免了在客户端验证证书时难以避免的弹框问题，又能够劫持HTTP明文数据，并同时保证客户端<code>HTTP</code>数据的传输，达到欺骗服务器与客户端的效果。</p><p>问题：这其实依赖的是用户在访问时直接输入网址，一般直接输入的域名，而不是输入 <code>https://域名</code>，这时候默认发出去了 http 请求，就会给人这种可乘之机。服务器那边通常是在网关设置将 http 流量转换成 https 流量。客户端只要保证最开始时就是发送 https 请求，这种攻击同样是没有可乘之机。</p><h3 id="情景分析"><a href="#情景分析" class="headerlink" title="情景分析"></a>情景分析</h3><ol><li>http 直接裸奔：直接通过 ssl sniff (ssl 嗅探) 就能直接完美实现中间人攻击，且不会被察觉</li><li>https 单向认证：服务端要提供证书，一般也只做到这个程度就够用了，理论上只要客户端不作死，中间人攻击就实现不了</li><li>https 双向认证：更高级的需求就是，服务端也要验证客户端，不是什么人都可以连接服务器，这样即使是密码什么的泄露，也无权操作服务器这边。要求客户端和服务端两边在建立连接的时候都要交换证书，去 ca 认证。通常用于企业接口对接</li></ol><p>对于普通的 toC 业务来说 https单向认证 基本是完全可以保证安全的，部分 toB 业务要求更高的安全性，会使用 https 双向认证</p><h3 id="addition"><a href="#addition" class="headerlink" title="addition"></a>addition</h3><p><a href="https://blog.csdn.net/paolei/article/details/88028467">关于Https安全性问题、双向验证防止中间人攻击问题_缺少相应的安全校验很容易导致中间人攻击</a></p><p><a href="https://www.jianshu.com/p/e680716ba8eb">HTTPS、单向认证、双向认证，中间者攻击</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSL </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
